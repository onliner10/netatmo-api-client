{-
   Netatmo

   <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 

   OpenAPI Version: 3.0.1
   Netatmo API version: 1.1.3
   Contact: contact-api@netatmo.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Netatmo.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Netatmo.Model where

import Netatmo.Core
import Netatmo.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AppType
newtype AppType = AppType { unAppType :: E'AppType } deriving (P.Eq, P.Show)

-- ** AppTypeText
newtype AppTypeText = AppTypeText { unAppTypeText :: Text } deriving (P.Eq, P.Show)

-- ** DateBegin
newtype DateBegin = DateBegin { unDateBegin :: Int } deriving (P.Eq, P.Show)

-- ** DateEnd
newtype DateEnd = DateEnd { unDateEnd :: Text } deriving (P.Eq, P.Show)

-- ** DeviceId
newtype DeviceId = DeviceId { unDeviceId :: Text } deriving (P.Eq, P.Show)

-- ** EventId
newtype EventId = EventId { unEventId :: Text } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Bool } deriving (P.Eq, P.Show)

-- ** GetFavorites
newtype GetFavorites = GetFavorites { unGetFavorites :: Bool } deriving (P.Eq, P.Show)

-- ** HomeId
newtype HomeId = HomeId { unHomeId :: Text } deriving (P.Eq, P.Show)

-- ** ImageId
newtype ImageId = ImageId { unImageId :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** LatNe
newtype LatNe = LatNe { unLatNe :: Int } deriving (P.Eq, P.Show)

-- ** LatSw
newtype LatSw = LatSw { unLatSw :: Int } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** LonNe
newtype LonNe = LonNe { unLonNe :: Int } deriving (P.Eq, P.Show)

-- ** LonSw
newtype LonSw = LonSw { unLonSw :: Int } deriving (P.Eq, P.Show)

-- ** ModuleId
newtype ModuleId = ModuleId { unModuleId :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** Optimize
newtype Optimize = Optimize { unOptimize :: Bool } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: [E'Type] } deriving (P.Eq, P.Show)

-- ** PersonId
newtype PersonId = PersonId { unPersonId :: Text } deriving (P.Eq, P.Show)

-- ** PersonIds
newtype PersonIds = PersonIds { unPersonIds :: Text } deriving (P.Eq, P.Show)

-- ** RealTime
newtype RealTime = RealTime { unRealTime :: Bool } deriving (P.Eq, P.Show)

-- ** RequiredData
newtype RequiredData = RequiredData { unRequiredData :: [E'RequiredData] } deriving (P.Eq, P.Show)

-- ** Scale
newtype Scale = Scale { unScale :: E'Scale } deriving (P.Eq, P.Show)

-- ** ScheduleId
newtype ScheduleId = ScheduleId { unScheduleId :: Text } deriving (P.Eq, P.Show)

-- ** SetpointEndtime
newtype SetpointEndtime = SetpointEndtime { unSetpointEndtime :: Int } deriving (P.Eq, P.Show)

-- ** SetpointMode
newtype SetpointMode = SetpointMode { unSetpointMode :: E'SetpointMode } deriving (P.Eq, P.Show)

-- ** SetpointTemp
newtype SetpointTemp = SetpointTemp { unSetpointTemp :: Float } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** NADashboardData
-- | NADashboardData
data NADashboardData = NADashboardData
  { nADashboardDataTimeUtc :: !(Maybe Int) -- ^ "time_utc"
  , nADashboardDataDeviceId :: !(Maybe Float) -- ^ "device_id"
  , nADashboardDataBoilerOn :: !(Maybe Int) -- ^ "BoilerOn"
  , nADashboardDataBoilerOff :: !(Maybe Int) -- ^ "BoilerOff"
  , nADashboardDataTemperature :: !(Maybe Float) -- ^ "Temperature" - Last temperature measure @ time_utc (in °C)
  , nADashboardDataTempTrend :: !(Maybe Text) -- ^ "temp_trend" - Temperature evolution trend
  , nADashboardDataDateMaxTemp :: !(Maybe Int) -- ^ "date_max_temp" - Timestamp when max temperature was measured
  , nADashboardDataDateMinTemp :: !(Maybe Int) -- ^ "date_min_temp" - Timestamp when min temperature was measured
  , nADashboardDataMinTemp :: !(Maybe Float) -- ^ "min_temp" - Max temperature of the day (measured @ date_max_temp)
  , nADashboardDataMaxTemp :: !(Maybe Float) -- ^ "max_temp" - Min temperature of the day (measured @ date_min_temp)
  , nADashboardDataAbsolutePressure :: !(Maybe Float) -- ^ "AbsolutePressure" - Real measured pressure @ time_utc (in mb)
  , nADashboardDataCo2 :: !(Maybe Float) -- ^ "CO2" - Last Co2 measured @ time_utc (in ppm)
  , nADashboardDataHumidity :: !(Maybe Float) -- ^ "Humidity" - Last humidity measured @ time_utc (in %)
  , nADashboardDataNoise :: !(Maybe Float) -- ^ "Noise" - Last noise measured @ time_utc (in db)
  , nADashboardDataPressure :: !(Maybe Float) -- ^ "Pressure" - Last Sea level pressure measured @ time_utc (in mb)
  , nADashboardDataPressureTrend :: !(Maybe Text) -- ^ "pressure_trend" - Pressure evolution trend
  , nADashboardDataRain :: !(Maybe Float) -- ^ "Rain" - Last rain measured (in mm)
  , nADashboardDataSumRain1 :: !(Maybe Float) -- ^ "sum_rain_1" - Amount of rain in last hour
  , nADashboardDataSumRain24 :: !(Maybe Float) -- ^ "sum_rain_24" - Amount of rain today
  , nADashboardDataWindAngle :: !(Maybe Int) -- ^ "WindAngle" - Current 5 min average wind direction measured @ time_utc (in °)
  , nADashboardDataGustAngle :: !(Maybe Int) -- ^ "GustAngle" - Direction of the last 5 min highest gust wind
  , nADashboardDataWindStrength :: !(Maybe Int) -- ^ "WindStrength" - Current 5 min average wind speed measured @ time_utc (in km/h)
  , nADashboardDataMaxWindStr :: !(Maybe Int) -- ^ "max_wind_str"
  , nADashboardDataDateMaxWindStr :: !(Maybe Int) -- ^ "date_max_wind_str" - Timestamp when max wind strength was measured
  , nADashboardDataGustStrength :: !(Maybe Int) -- ^ "GustStrength" - Speed of the last 5 min highest gust wind
  , nADashboardDataHealthIdx :: !(Maybe Int) -- ^ "health_idx" - Current health index: 0 &#x3D; Healthy, 1 &#x3D; Fine, 2 &#x3D; Fair, 3 &#x3D; Poor, 4 &#x3D; Unhealthy
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NADashboardData
instance A.FromJSON NADashboardData where
  parseJSON = A.withObject "NADashboardData" $ \o ->
    NADashboardData
      <$> (o .:? "time_utc")
      <*> (o .:? "device_id")
      <*> (o .:? "BoilerOn")
      <*> (o .:? "BoilerOff")
      <*> (o .:? "Temperature")
      <*> (o .:? "temp_trend")
      <*> (o .:? "date_max_temp")
      <*> (o .:? "date_min_temp")
      <*> (o .:? "min_temp")
      <*> (o .:? "max_temp")
      <*> (o .:? "AbsolutePressure")
      <*> (o .:? "CO2")
      <*> (o .:? "Humidity")
      <*> (o .:? "Noise")
      <*> (o .:? "Pressure")
      <*> (o .:? "pressure_trend")
      <*> (o .:? "Rain")
      <*> (o .:? "sum_rain_1")
      <*> (o .:? "sum_rain_24")
      <*> (o .:? "WindAngle")
      <*> (o .:? "GustAngle")
      <*> (o .:? "WindStrength")
      <*> (o .:? "max_wind_str")
      <*> (o .:? "date_max_wind_str")
      <*> (o .:? "GustStrength")
      <*> (o .:? "health_idx")

-- | ToJSON NADashboardData
instance A.ToJSON NADashboardData where
  toJSON NADashboardData {..} =
   _omitNulls
      [ "time_utc" .= nADashboardDataTimeUtc
      , "device_id" .= nADashboardDataDeviceId
      , "BoilerOn" .= nADashboardDataBoilerOn
      , "BoilerOff" .= nADashboardDataBoilerOff
      , "Temperature" .= nADashboardDataTemperature
      , "temp_trend" .= nADashboardDataTempTrend
      , "date_max_temp" .= nADashboardDataDateMaxTemp
      , "date_min_temp" .= nADashboardDataDateMinTemp
      , "min_temp" .= nADashboardDataMinTemp
      , "max_temp" .= nADashboardDataMaxTemp
      , "AbsolutePressure" .= nADashboardDataAbsolutePressure
      , "CO2" .= nADashboardDataCo2
      , "Humidity" .= nADashboardDataHumidity
      , "Noise" .= nADashboardDataNoise
      , "Pressure" .= nADashboardDataPressure
      , "pressure_trend" .= nADashboardDataPressureTrend
      , "Rain" .= nADashboardDataRain
      , "sum_rain_1" .= nADashboardDataSumRain1
      , "sum_rain_24" .= nADashboardDataSumRain24
      , "WindAngle" .= nADashboardDataWindAngle
      , "GustAngle" .= nADashboardDataGustAngle
      , "WindStrength" .= nADashboardDataWindStrength
      , "max_wind_str" .= nADashboardDataMaxWindStr
      , "date_max_wind_str" .= nADashboardDataDateMaxWindStr
      , "GustStrength" .= nADashboardDataGustStrength
      , "health_idx" .= nADashboardDataHealthIdx
      ]


-- | Construct a value of type 'NADashboardData' (by applying it's required fields, if any)
mkNADashboardData
  :: NADashboardData
mkNADashboardData =
  NADashboardData
  { nADashboardDataTimeUtc = Nothing
  , nADashboardDataDeviceId = Nothing
  , nADashboardDataBoilerOn = Nothing
  , nADashboardDataBoilerOff = Nothing
  , nADashboardDataTemperature = Nothing
  , nADashboardDataTempTrend = Nothing
  , nADashboardDataDateMaxTemp = Nothing
  , nADashboardDataDateMinTemp = Nothing
  , nADashboardDataMinTemp = Nothing
  , nADashboardDataMaxTemp = Nothing
  , nADashboardDataAbsolutePressure = Nothing
  , nADashboardDataCo2 = Nothing
  , nADashboardDataHumidity = Nothing
  , nADashboardDataNoise = Nothing
  , nADashboardDataPressure = Nothing
  , nADashboardDataPressureTrend = Nothing
  , nADashboardDataRain = Nothing
  , nADashboardDataSumRain1 = Nothing
  , nADashboardDataSumRain24 = Nothing
  , nADashboardDataWindAngle = Nothing
  , nADashboardDataGustAngle = Nothing
  , nADashboardDataWindStrength = Nothing
  , nADashboardDataMaxWindStr = Nothing
  , nADashboardDataDateMaxWindStr = Nothing
  , nADashboardDataGustStrength = Nothing
  , nADashboardDataHealthIdx = Nothing
  }

-- ** NADate
-- | NADate
data NADate = NADate
  { nADateSec :: !(Maybe Int) -- ^ "sec"
  , nADateUsec :: !(Maybe Int) -- ^ "usec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NADate
instance A.FromJSON NADate where
  parseJSON = A.withObject "NADate" $ \o ->
    NADate
      <$> (o .:? "sec")
      <*> (o .:? "usec")

-- | ToJSON NADate
instance A.ToJSON NADate where
  toJSON NADate {..} =
   _omitNulls
      [ "sec" .= nADateSec
      , "usec" .= nADateUsec
      ]


-- | Construct a value of type 'NADate' (by applying it's required fields, if any)
mkNADate
  :: NADate
mkNADate =
  NADate
  { nADateSec = Nothing
  , nADateUsec = Nothing
  }

-- ** NADevice
-- | NADevice
data NADevice = NADevice
  { nADeviceId :: !(Maybe Text) -- ^ "_id"
  , nADeviceBehavior :: !(Maybe Int) -- ^ "behavior"
  , nADeviceCipherId :: !(Maybe Text) -- ^ "cipher_id"
  , nADeviceDateSetup :: !(Maybe NADate) -- ^ "date_setup"
  , nADeviceFirmware :: !(Maybe Int) -- ^ "firmware"
  , nADeviceHwVersion :: !(Maybe Int) -- ^ "hw_version"
  , nADeviceHeatingSystem :: !(Maybe NAHeatingSystem) -- ^ "heating_system"
  , nADeviceHouseModel :: !(Maybe NAHouseModel) -- ^ "house_model"
  , nADeviceIp :: !(Maybe Text) -- ^ "ip"
  , nADeviceLastFwUpdate :: !(Maybe Int) -- ^ "last_fw_update"
  , nADeviceLastRadioStore :: !(Maybe Int) -- ^ "last_radio_store"
  , nADeviceLastStatusStore :: !(Maybe Int) -- ^ "last_status_store"
  , nADeviceLastUpgrade :: !(Maybe Int) -- ^ "last_upgrade"
  , nADeviceModuleName :: !(Maybe Text) -- ^ "module_name"
  , nADeviceModules :: !(Maybe [Text]) -- ^ "modules" - It lists which modules are linked with this device
  , nADevicePlace :: !(Maybe NAPlace) -- ^ "place"
  , nADeviceSetpoint :: !(Maybe A.Value) -- ^ "setpoint"
  , nADeviceSetpointDefaultDuration :: !(Maybe Int) -- ^ "setpoint_default_duration"
  , nADeviceSetpointOrder :: !(Maybe (Map.Map String [NAObject])) -- ^ "setpoint_order"
  , nADevicePublicExtData :: !(Maybe Bool) -- ^ "public_ext_data"
  , nADeviceStationName :: !(Maybe Text) -- ^ "station_name"
  , nADeviceThermProgram :: !(Maybe (Map.Map String NAThermProgram)) -- ^ "therm_program"
  , nADeviceThermProgramBackup :: !(Maybe (Map.Map String [NAThermProgram])) -- ^ "therm_program_backup"
  , nADeviceThermProgramOrder :: !(Maybe (Map.Map String [NAObject])) -- ^ "therm_program_order"
  , nADeviceType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nADeviceUserOwner :: !(Maybe [Text]) -- ^ "user_owner"
  , nADeviceUdpConn :: !(Maybe Bool) -- ^ "udp_conn"
  , nADeviceWifiStatus :: !(Maybe Int) -- ^ "wifi_status" - It contains the current wifi status. The different thresholds to take into account are RSSI_THRESHOLD_0 &#x3D; 86 bad signal RSSI_THRESHOLD_1 &#x3D; 71 middle quality signal RSSI_THRESHOLD_2 &#x3D; 56 good signal 
  , nADeviceNewFeatureAvail :: !(Maybe Bool) -- ^ "new_feature_avail"
  , nADeviceFirstPidAvail :: !(Maybe Bool) -- ^ "first_pid_avail"
  , nADeviceDashboardData :: !(Maybe NADashboardData) -- ^ "dashboard_data"
  , nADeviceDataType :: !(Maybe [Text]) -- ^ "data_type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NADevice
instance A.FromJSON NADevice where
  parseJSON = A.withObject "NADevice" $ \o ->
    NADevice
      <$> (o .:? "_id")
      <*> (o .:? "behavior")
      <*> (o .:? "cipher_id")
      <*> (o .:? "date_setup")
      <*> (o .:? "firmware")
      <*> (o .:? "hw_version")
      <*> (o .:? "heating_system")
      <*> (o .:? "house_model")
      <*> (o .:? "ip")
      <*> (o .:? "last_fw_update")
      <*> (o .:? "last_radio_store")
      <*> (o .:? "last_status_store")
      <*> (o .:? "last_upgrade")
      <*> (o .:? "module_name")
      <*> (o .:? "modules")
      <*> (o .:? "place")
      <*> (o .:? "setpoint")
      <*> (o .:? "setpoint_default_duration")
      <*> (o .:? "setpoint_order")
      <*> (o .:? "public_ext_data")
      <*> (o .:? "station_name")
      <*> (o .:? "therm_program")
      <*> (o .:? "therm_program_backup")
      <*> (o .:? "therm_program_order")
      <*> (o .:? "type")
      <*> (o .:? "user_owner")
      <*> (o .:? "udp_conn")
      <*> (o .:? "wifi_status")
      <*> (o .:? "new_feature_avail")
      <*> (o .:? "first_pid_avail")
      <*> (o .:? "dashboard_data")
      <*> (o .:? "data_type")

-- | ToJSON NADevice
instance A.ToJSON NADevice where
  toJSON NADevice {..} =
   _omitNulls
      [ "_id" .= nADeviceId
      , "behavior" .= nADeviceBehavior
      , "cipher_id" .= nADeviceCipherId
      , "date_setup" .= nADeviceDateSetup
      , "firmware" .= nADeviceFirmware
      , "hw_version" .= nADeviceHwVersion
      , "heating_system" .= nADeviceHeatingSystem
      , "house_model" .= nADeviceHouseModel
      , "ip" .= nADeviceIp
      , "last_fw_update" .= nADeviceLastFwUpdate
      , "last_radio_store" .= nADeviceLastRadioStore
      , "last_status_store" .= nADeviceLastStatusStore
      , "last_upgrade" .= nADeviceLastUpgrade
      , "module_name" .= nADeviceModuleName
      , "modules" .= nADeviceModules
      , "place" .= nADevicePlace
      , "setpoint" .= nADeviceSetpoint
      , "setpoint_default_duration" .= nADeviceSetpointDefaultDuration
      , "setpoint_order" .= nADeviceSetpointOrder
      , "public_ext_data" .= nADevicePublicExtData
      , "station_name" .= nADeviceStationName
      , "therm_program" .= nADeviceThermProgram
      , "therm_program_backup" .= nADeviceThermProgramBackup
      , "therm_program_order" .= nADeviceThermProgramOrder
      , "type" .= nADeviceType
      , "user_owner" .= nADeviceUserOwner
      , "udp_conn" .= nADeviceUdpConn
      , "wifi_status" .= nADeviceWifiStatus
      , "new_feature_avail" .= nADeviceNewFeatureAvail
      , "first_pid_avail" .= nADeviceFirstPidAvail
      , "dashboard_data" .= nADeviceDashboardData
      , "data_type" .= nADeviceDataType
      ]


-- | Construct a value of type 'NADevice' (by applying it's required fields, if any)
mkNADevice
  :: NADevice
mkNADevice =
  NADevice
  { nADeviceId = Nothing
  , nADeviceBehavior = Nothing
  , nADeviceCipherId = Nothing
  , nADeviceDateSetup = Nothing
  , nADeviceFirmware = Nothing
  , nADeviceHwVersion = Nothing
  , nADeviceHeatingSystem = Nothing
  , nADeviceHouseModel = Nothing
  , nADeviceIp = Nothing
  , nADeviceLastFwUpdate = Nothing
  , nADeviceLastRadioStore = Nothing
  , nADeviceLastStatusStore = Nothing
  , nADeviceLastUpgrade = Nothing
  , nADeviceModuleName = Nothing
  , nADeviceModules = Nothing
  , nADevicePlace = Nothing
  , nADeviceSetpoint = Nothing
  , nADeviceSetpointDefaultDuration = Nothing
  , nADeviceSetpointOrder = Nothing
  , nADevicePublicExtData = Nothing
  , nADeviceStationName = Nothing
  , nADeviceThermProgram = Nothing
  , nADeviceThermProgramBackup = Nothing
  , nADeviceThermProgramOrder = Nothing
  , nADeviceType = Nothing
  , nADeviceUserOwner = Nothing
  , nADeviceUdpConn = Nothing
  , nADeviceWifiStatus = Nothing
  , nADeviceNewFeatureAvail = Nothing
  , nADeviceFirstPidAvail = Nothing
  , nADeviceDashboardData = Nothing
  , nADeviceDataType = Nothing
  }

-- ** NADeviceListBody
-- | NADeviceListBody
data NADeviceListBody = NADeviceListBody
  { nADeviceListBodyDevices :: !(Maybe [NADevice]) -- ^ "devices"
  , nADeviceListBodyModules :: !(Maybe [NAModule]) -- ^ "modules"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NADeviceListBody
instance A.FromJSON NADeviceListBody where
  parseJSON = A.withObject "NADeviceListBody" $ \o ->
    NADeviceListBody
      <$> (o .:? "devices")
      <*> (o .:? "modules")

-- | ToJSON NADeviceListBody
instance A.ToJSON NADeviceListBody where
  toJSON NADeviceListBody {..} =
   _omitNulls
      [ "devices" .= nADeviceListBodyDevices
      , "modules" .= nADeviceListBodyModules
      ]


-- | Construct a value of type 'NADeviceListBody' (by applying it's required fields, if any)
mkNADeviceListBody
  :: NADeviceListBody
mkNADeviceListBody =
  NADeviceListBody
  { nADeviceListBodyDevices = Nothing
  , nADeviceListBodyModules = Nothing
  }

-- ** NADeviceListResponse
-- | NADeviceListResponse
data NADeviceListResponse = NADeviceListResponse
  { nADeviceListResponseStatus :: !(Maybe Text) -- ^ "status"
  , nADeviceListResponseBody :: !(Maybe NADeviceListBody) -- ^ "body"
  , nADeviceListResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nADeviceListResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NADeviceListResponse
instance A.FromJSON NADeviceListResponse where
  parseJSON = A.withObject "NADeviceListResponse" $ \o ->
    NADeviceListResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NADeviceListResponse
instance A.ToJSON NADeviceListResponse where
  toJSON NADeviceListResponse {..} =
   _omitNulls
      [ "status" .= nADeviceListResponseStatus
      , "body" .= nADeviceListResponseBody
      , "time_exec" .= nADeviceListResponseTimeExec
      , "time_server" .= nADeviceListResponseTimeServer
      ]


-- | Construct a value of type 'NADeviceListResponse' (by applying it's required fields, if any)
mkNADeviceListResponse
  :: NADeviceListResponse
mkNADeviceListResponse =
  NADeviceListResponse
  { nADeviceListResponseStatus = Nothing
  , nADeviceListResponseBody = Nothing
  , nADeviceListResponseTimeExec = Nothing
  , nADeviceListResponseTimeServer = Nothing
  }

-- ** NAHealthyHomeCoach
-- | NAHealthyHomeCoach
data NAHealthyHomeCoach = NAHealthyHomeCoach
  { nAHealthyHomeCoachId :: !(Maybe Text) -- ^ "_id"
  , nAHealthyHomeCoachCipherId :: !(Maybe Text) -- ^ "cipher_id"
  , nAHealthyHomeCoachLastStatusStore :: !(Maybe Int) -- ^ "last_status_store"
  , nAHealthyHomeCoachPlace :: !(Maybe NAPlace) -- ^ "place"
  , nAHealthyHomeCoachType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NHC: Healthy Home Coach 
  , nAHealthyHomeCoachDashboardData :: !(Maybe NADashboardData) -- ^ "dashboard_data"
  , nAHealthyHomeCoachDataType :: !(Maybe [Text]) -- ^ "data_type"
  , nAHealthyHomeCoachCo2Calibrating :: !(Maybe Bool) -- ^ "co2_calibrating"
  , nAHealthyHomeCoachDateSetup :: !(Maybe Int) -- ^ "date_setup"
  , nAHealthyHomeCoachLastSetup :: !(Maybe Int) -- ^ "last_setup"
  , nAHealthyHomeCoachFirmware :: !(Maybe Int) -- ^ "firmware"
  , nAHealthyHomeCoachLastUpgrade :: !(Maybe Int) -- ^ "last_upgrade"
  , nAHealthyHomeCoachWifiStatus :: !(Maybe Int) -- ^ "wifi_status" - It contains the current wifi status. The different thresholds to take into account are RSSI_THRESHOLD_0 &#x3D; 86 bad signal RSSI_THRESHOLD_1 &#x3D; 71 middle quality signal RSSI_THRESHOLD_2 &#x3D; 56 good signal 
  , nAHealthyHomeCoachName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHealthyHomeCoach
instance A.FromJSON NAHealthyHomeCoach where
  parseJSON = A.withObject "NAHealthyHomeCoach" $ \o ->
    NAHealthyHomeCoach
      <$> (o .:? "_id")
      <*> (o .:? "cipher_id")
      <*> (o .:? "last_status_store")
      <*> (o .:? "place")
      <*> (o .:? "type")
      <*> (o .:? "dashboard_data")
      <*> (o .:? "data_type")
      <*> (o .:? "co2_calibrating")
      <*> (o .:? "date_setup")
      <*> (o .:? "last_setup")
      <*> (o .:? "firmware")
      <*> (o .:? "last_upgrade")
      <*> (o .:? "wifi_status")
      <*> (o .:? "name")

-- | ToJSON NAHealthyHomeCoach
instance A.ToJSON NAHealthyHomeCoach where
  toJSON NAHealthyHomeCoach {..} =
   _omitNulls
      [ "_id" .= nAHealthyHomeCoachId
      , "cipher_id" .= nAHealthyHomeCoachCipherId
      , "last_status_store" .= nAHealthyHomeCoachLastStatusStore
      , "place" .= nAHealthyHomeCoachPlace
      , "type" .= nAHealthyHomeCoachType
      , "dashboard_data" .= nAHealthyHomeCoachDashboardData
      , "data_type" .= nAHealthyHomeCoachDataType
      , "co2_calibrating" .= nAHealthyHomeCoachCo2Calibrating
      , "date_setup" .= nAHealthyHomeCoachDateSetup
      , "last_setup" .= nAHealthyHomeCoachLastSetup
      , "firmware" .= nAHealthyHomeCoachFirmware
      , "last_upgrade" .= nAHealthyHomeCoachLastUpgrade
      , "wifi_status" .= nAHealthyHomeCoachWifiStatus
      , "name" .= nAHealthyHomeCoachName
      ]


-- | Construct a value of type 'NAHealthyHomeCoach' (by applying it's required fields, if any)
mkNAHealthyHomeCoach
  :: NAHealthyHomeCoach
mkNAHealthyHomeCoach =
  NAHealthyHomeCoach
  { nAHealthyHomeCoachId = Nothing
  , nAHealthyHomeCoachCipherId = Nothing
  , nAHealthyHomeCoachLastStatusStore = Nothing
  , nAHealthyHomeCoachPlace = Nothing
  , nAHealthyHomeCoachType = Nothing
  , nAHealthyHomeCoachDashboardData = Nothing
  , nAHealthyHomeCoachDataType = Nothing
  , nAHealthyHomeCoachCo2Calibrating = Nothing
  , nAHealthyHomeCoachDateSetup = Nothing
  , nAHealthyHomeCoachLastSetup = Nothing
  , nAHealthyHomeCoachFirmware = Nothing
  , nAHealthyHomeCoachLastUpgrade = Nothing
  , nAHealthyHomeCoachWifiStatus = Nothing
  , nAHealthyHomeCoachName = Nothing
  }

-- ** NAHealthyHomeCoachDataBody
-- | NAHealthyHomeCoachDataBody
data NAHealthyHomeCoachDataBody = NAHealthyHomeCoachDataBody
  { nAHealthyHomeCoachDataBodyDevices :: !(Maybe [NAHealthyHomeCoach]) -- ^ "devices"
  , nAHealthyHomeCoachDataBodyUser :: !(Maybe NAUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHealthyHomeCoachDataBody
instance A.FromJSON NAHealthyHomeCoachDataBody where
  parseJSON = A.withObject "NAHealthyHomeCoachDataBody" $ \o ->
    NAHealthyHomeCoachDataBody
      <$> (o .:? "devices")
      <*> (o .:? "user")

-- | ToJSON NAHealthyHomeCoachDataBody
instance A.ToJSON NAHealthyHomeCoachDataBody where
  toJSON NAHealthyHomeCoachDataBody {..} =
   _omitNulls
      [ "devices" .= nAHealthyHomeCoachDataBodyDevices
      , "user" .= nAHealthyHomeCoachDataBodyUser
      ]


-- | Construct a value of type 'NAHealthyHomeCoachDataBody' (by applying it's required fields, if any)
mkNAHealthyHomeCoachDataBody
  :: NAHealthyHomeCoachDataBody
mkNAHealthyHomeCoachDataBody =
  NAHealthyHomeCoachDataBody
  { nAHealthyHomeCoachDataBodyDevices = Nothing
  , nAHealthyHomeCoachDataBodyUser = Nothing
  }

-- ** NAHealthyHomeCoachDataResponse
-- | NAHealthyHomeCoachDataResponse
data NAHealthyHomeCoachDataResponse = NAHealthyHomeCoachDataResponse
  { nAHealthyHomeCoachDataResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAHealthyHomeCoachDataResponseBody :: !(Maybe NAHealthyHomeCoachDataBody) -- ^ "body"
  , nAHealthyHomeCoachDataResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAHealthyHomeCoachDataResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHealthyHomeCoachDataResponse
instance A.FromJSON NAHealthyHomeCoachDataResponse where
  parseJSON = A.withObject "NAHealthyHomeCoachDataResponse" $ \o ->
    NAHealthyHomeCoachDataResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAHealthyHomeCoachDataResponse
instance A.ToJSON NAHealthyHomeCoachDataResponse where
  toJSON NAHealthyHomeCoachDataResponse {..} =
   _omitNulls
      [ "status" .= nAHealthyHomeCoachDataResponseStatus
      , "body" .= nAHealthyHomeCoachDataResponseBody
      , "time_exec" .= nAHealthyHomeCoachDataResponseTimeExec
      , "time_server" .= nAHealthyHomeCoachDataResponseTimeServer
      ]


-- | Construct a value of type 'NAHealthyHomeCoachDataResponse' (by applying it's required fields, if any)
mkNAHealthyHomeCoachDataResponse
  :: NAHealthyHomeCoachDataResponse
mkNAHealthyHomeCoachDataResponse =
  NAHealthyHomeCoachDataResponse
  { nAHealthyHomeCoachDataResponseStatus = Nothing
  , nAHealthyHomeCoachDataResponseBody = Nothing
  , nAHealthyHomeCoachDataResponseTimeExec = Nothing
  , nAHealthyHomeCoachDataResponseTimeServer = Nothing
  }

-- ** NAHeatingSystem
-- | NAHeatingSystem
data NAHeatingSystem = NAHeatingSystem
  { nAHeatingSystemHeatingEnergy :: !(Maybe Text) -- ^ "heating_energy"
  , nAHeatingSystemHeatingSystemWindowSeen :: !(Maybe Bool) -- ^ "heating_system_window_seen"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHeatingSystem
instance A.FromJSON NAHeatingSystem where
  parseJSON = A.withObject "NAHeatingSystem" $ \o ->
    NAHeatingSystem
      <$> (o .:? "heating_energy")
      <*> (o .:? "heating_system_window_seen")

-- | ToJSON NAHeatingSystem
instance A.ToJSON NAHeatingSystem where
  toJSON NAHeatingSystem {..} =
   _omitNulls
      [ "heating_energy" .= nAHeatingSystemHeatingEnergy
      , "heating_system_window_seen" .= nAHeatingSystemHeatingSystemWindowSeen
      ]


-- | Construct a value of type 'NAHeatingSystem' (by applying it's required fields, if any)
mkNAHeatingSystem
  :: NAHeatingSystem
mkNAHeatingSystem =
  NAHeatingSystem
  { nAHeatingSystemHeatingEnergy = Nothing
  , nAHeatingSystemHeatingSystemWindowSeen = Nothing
  }

-- ** NAHouseModel
-- | NAHouseModel
data NAHouseModel = NAHouseModel
  { nAHouseModelAlgoType :: !(Maybe Text) -- ^ "algo_type"
  , nAHouseModelCa :: !(Maybe NAHouseModelCa) -- ^ "ca"
  , nAHouseModelExtTemps :: !(Maybe (Map.Map String Int)) -- ^ "ext_temps"
  , nAHouseModelFirstAnticipateAvail :: !(Maybe Bool) -- ^ "first_anticipate_avail"
  , nAHouseModelFirstPidAvail :: !(Maybe Bool) -- ^ "first_pid_avail"
  , nAHouseModelGefs :: !(Maybe NAStation) -- ^ "gefs"
  , nAHouseModelInUse :: !(Maybe Text) -- ^ "in_use"
  , nAHouseModelLastComputeTry :: !(Maybe NADate) -- ^ "last_compute_try"
  , nAHouseModelLinkStation :: !(Maybe NALinkStation) -- ^ "link_station"
  , nAHouseModelPidAlgo :: !(Maybe NAPidAlgo) -- ^ "pid_algo"
  , nAHouseModelStation :: !(Maybe NAStation) -- ^ "station"
  , nAHouseModelPreferedAlgoType :: !(Maybe Text) -- ^ "prefered_algo_type"
  , nAHouseModelSimpleAlgo :: !(Maybe NASimpleAlgo) -- ^ "simple_algo"
  , nAHouseModelTime :: !(Maybe NADate) -- ^ "time"
  , nAHouseModelStationFirsttimeAnticipate :: !(Maybe Bool) -- ^ "station_firsttime_anticipate"
  , nAHouseModelTimeAlgoChanged :: !(Maybe Int) -- ^ "time_algo_changed"
  , nAHouseModelTimePidComputed :: !(Maybe Int) -- ^ "time_pid_computed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHouseModel
instance A.FromJSON NAHouseModel where
  parseJSON = A.withObject "NAHouseModel" $ \o ->
    NAHouseModel
      <$> (o .:? "algo_type")
      <*> (o .:? "ca")
      <*> (o .:? "ext_temps")
      <*> (o .:? "first_anticipate_avail")
      <*> (o .:? "first_pid_avail")
      <*> (o .:? "gefs")
      <*> (o .:? "in_use")
      <*> (o .:? "last_compute_try")
      <*> (o .:? "link_station")
      <*> (o .:? "pid_algo")
      <*> (o .:? "station")
      <*> (o .:? "prefered_algo_type")
      <*> (o .:? "simple_algo")
      <*> (o .:? "time")
      <*> (o .:? "station_firsttime_anticipate")
      <*> (o .:? "time_algo_changed")
      <*> (o .:? "time_pid_computed")

-- | ToJSON NAHouseModel
instance A.ToJSON NAHouseModel where
  toJSON NAHouseModel {..} =
   _omitNulls
      [ "algo_type" .= nAHouseModelAlgoType
      , "ca" .= nAHouseModelCa
      , "ext_temps" .= nAHouseModelExtTemps
      , "first_anticipate_avail" .= nAHouseModelFirstAnticipateAvail
      , "first_pid_avail" .= nAHouseModelFirstPidAvail
      , "gefs" .= nAHouseModelGefs
      , "in_use" .= nAHouseModelInUse
      , "last_compute_try" .= nAHouseModelLastComputeTry
      , "link_station" .= nAHouseModelLinkStation
      , "pid_algo" .= nAHouseModelPidAlgo
      , "station" .= nAHouseModelStation
      , "prefered_algo_type" .= nAHouseModelPreferedAlgoType
      , "simple_algo" .= nAHouseModelSimpleAlgo
      , "time" .= nAHouseModelTime
      , "station_firsttime_anticipate" .= nAHouseModelStationFirsttimeAnticipate
      , "time_algo_changed" .= nAHouseModelTimeAlgoChanged
      , "time_pid_computed" .= nAHouseModelTimePidComputed
      ]


-- | Construct a value of type 'NAHouseModel' (by applying it's required fields, if any)
mkNAHouseModel
  :: NAHouseModel
mkNAHouseModel =
  NAHouseModel
  { nAHouseModelAlgoType = Nothing
  , nAHouseModelCa = Nothing
  , nAHouseModelExtTemps = Nothing
  , nAHouseModelFirstAnticipateAvail = Nothing
  , nAHouseModelFirstPidAvail = Nothing
  , nAHouseModelGefs = Nothing
  , nAHouseModelInUse = Nothing
  , nAHouseModelLastComputeTry = Nothing
  , nAHouseModelLinkStation = Nothing
  , nAHouseModelPidAlgo = Nothing
  , nAHouseModelStation = Nothing
  , nAHouseModelPreferedAlgoType = Nothing
  , nAHouseModelSimpleAlgo = Nothing
  , nAHouseModelTime = Nothing
  , nAHouseModelStationFirsttimeAnticipate = Nothing
  , nAHouseModelTimeAlgoChanged = Nothing
  , nAHouseModelTimePidComputed = Nothing
  }

-- ** NAHouseModelCa
-- | NAHouseModelCa
data NAHouseModelCa = NAHouseModelCa
  { nAHouseModelCaTe :: !(Maybe Double) -- ^ "te"
  , nAHouseModelCaTi :: !(Maybe Int) -- ^ "ti"
  , nAHouseModelCaSo :: !(Maybe Text) -- ^ "so"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAHouseModelCa
instance A.FromJSON NAHouseModelCa where
  parseJSON = A.withObject "NAHouseModelCa" $ \o ->
    NAHouseModelCa
      <$> (o .:? "te")
      <*> (o .:? "ti")
      <*> (o .:? "so")

-- | ToJSON NAHouseModelCa
instance A.ToJSON NAHouseModelCa where
  toJSON NAHouseModelCa {..} =
   _omitNulls
      [ "te" .= nAHouseModelCaTe
      , "ti" .= nAHouseModelCaTi
      , "so" .= nAHouseModelCaSo
      ]


-- | Construct a value of type 'NAHouseModelCa' (by applying it's required fields, if any)
mkNAHouseModelCa
  :: NAHouseModelCa
mkNAHouseModelCa =
  NAHouseModelCa
  { nAHouseModelCaTe = Nothing
  , nAHouseModelCaTi = Nothing
  , nAHouseModelCaSo = Nothing
  }

-- ** NALinkStation
-- | NALinkStation
data NALinkStation = NALinkStation
  { nALinkStationMac :: !(Maybe Text) -- ^ "mac"
  , nALinkStationExt :: !(Maybe Text) -- ^ "ext"
  , nALinkStationTemperature :: !(Maybe Float) -- ^ "Temperature"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NALinkStation
instance A.FromJSON NALinkStation where
  parseJSON = A.withObject "NALinkStation" $ \o ->
    NALinkStation
      <$> (o .:? "mac")
      <*> (o .:? "ext")
      <*> (o .:? "Temperature")

-- | ToJSON NALinkStation
instance A.ToJSON NALinkStation where
  toJSON NALinkStation {..} =
   _omitNulls
      [ "mac" .= nALinkStationMac
      , "ext" .= nALinkStationExt
      , "Temperature" .= nALinkStationTemperature
      ]


-- | Construct a value of type 'NALinkStation' (by applying it's required fields, if any)
mkNALinkStation
  :: NALinkStation
mkNALinkStation =
  NALinkStation
  { nALinkStationMac = Nothing
  , nALinkStationExt = Nothing
  , nALinkStationTemperature = Nothing
  }

-- ** NAMain
-- | NAMain
data NAMain = NAMain
  { nAMainId :: !(Maybe Text) -- ^ "_id"
  , nAMainCipherId :: !(Maybe Text) -- ^ "cipher_id"
  , nAMainLastStatusStore :: !(Maybe Int) -- ^ "last_status_store"
  , nAMainModules :: !(Maybe [NAStationModule]) -- ^ "modules"
  , nAMainPlace :: !(Maybe NAPlace) -- ^ "place"
  , nAMainStationName :: !(Maybe Text) -- ^ "station_name"
  , nAMainType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nAMainDashboardData :: !(Maybe NADashboardData) -- ^ "dashboard_data"
  , nAMainDataType :: !(Maybe [Text]) -- ^ "data_type"
  , nAMainCo2Calibrating :: !(Maybe Bool) -- ^ "co2_calibrating"
  , nAMainDateSetup :: !(Maybe Int) -- ^ "date_setup"
  , nAMainLastSetup :: !(Maybe Int) -- ^ "last_setup"
  , nAMainModuleName :: !(Maybe Text) -- ^ "module_name"
  , nAMainFirmware :: !(Maybe Int) -- ^ "firmware"
  , nAMainLastUpgrade :: !(Maybe Int) -- ^ "last_upgrade"
  , nAMainWifiStatus :: !(Maybe Int) -- ^ "wifi_status" - It contains the current wifi status. The different thresholds to take into account are RSSI_THRESHOLD_0 &#x3D; 86 bad signal RSSI_THRESHOLD_1 &#x3D; 71 middle quality signal RSSI_THRESHOLD_2 &#x3D; 56 good signal 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAMain
instance A.FromJSON NAMain where
  parseJSON = A.withObject "NAMain" $ \o ->
    NAMain
      <$> (o .:? "_id")
      <*> (o .:? "cipher_id")
      <*> (o .:? "last_status_store")
      <*> (o .:? "modules")
      <*> (o .:? "place")
      <*> (o .:? "station_name")
      <*> (o .:? "type")
      <*> (o .:? "dashboard_data")
      <*> (o .:? "data_type")
      <*> (o .:? "co2_calibrating")
      <*> (o .:? "date_setup")
      <*> (o .:? "last_setup")
      <*> (o .:? "module_name")
      <*> (o .:? "firmware")
      <*> (o .:? "last_upgrade")
      <*> (o .:? "wifi_status")

-- | ToJSON NAMain
instance A.ToJSON NAMain where
  toJSON NAMain {..} =
   _omitNulls
      [ "_id" .= nAMainId
      , "cipher_id" .= nAMainCipherId
      , "last_status_store" .= nAMainLastStatusStore
      , "modules" .= nAMainModules
      , "place" .= nAMainPlace
      , "station_name" .= nAMainStationName
      , "type" .= nAMainType
      , "dashboard_data" .= nAMainDashboardData
      , "data_type" .= nAMainDataType
      , "co2_calibrating" .= nAMainCo2Calibrating
      , "date_setup" .= nAMainDateSetup
      , "last_setup" .= nAMainLastSetup
      , "module_name" .= nAMainModuleName
      , "firmware" .= nAMainFirmware
      , "last_upgrade" .= nAMainLastUpgrade
      , "wifi_status" .= nAMainWifiStatus
      ]


-- | Construct a value of type 'NAMain' (by applying it's required fields, if any)
mkNAMain
  :: NAMain
mkNAMain =
  NAMain
  { nAMainId = Nothing
  , nAMainCipherId = Nothing
  , nAMainLastStatusStore = Nothing
  , nAMainModules = Nothing
  , nAMainPlace = Nothing
  , nAMainStationName = Nothing
  , nAMainType = Nothing
  , nAMainDashboardData = Nothing
  , nAMainDataType = Nothing
  , nAMainCo2Calibrating = Nothing
  , nAMainDateSetup = Nothing
  , nAMainLastSetup = Nothing
  , nAMainModuleName = Nothing
  , nAMainFirmware = Nothing
  , nAMainLastUpgrade = Nothing
  , nAMainWifiStatus = Nothing
  }

-- ** NAMeasure
-- | NAMeasure
data NAMeasure = NAMeasure
  { nAMeasureRes :: !(Maybe A.Value) -- ^ "res"
  , nAMeasureType :: !(Maybe [Text]) -- ^ "type"
  , nAMeasureRain60min :: !(Maybe Double) -- ^ "rain_60min"
  , nAMeasureRain24h :: !(Maybe Double) -- ^ "rain_24h"
  , nAMeasureRainLive :: !(Maybe Double) -- ^ "rain_live"
  , nAMeasureRainUtc :: !(Maybe Integer) -- ^ "rain_utc"
  , nAMeasureWindStrength :: !(Maybe Double) -- ^ "wind_strength"
  , nAMeasureWindAngle :: !(Maybe Double) -- ^ "wind_angle"
  , nAMeasureGustStrength :: !(Maybe Double) -- ^ "gust_strength"
  , nAMeasureGustAngle :: !(Maybe Double) -- ^ "gust_angle"
  , nAMeasureWindTimeutc :: !(Maybe Integer) -- ^ "wind_timeutc&quot;"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAMeasure
instance A.FromJSON NAMeasure where
  parseJSON = A.withObject "NAMeasure" $ \o ->
    NAMeasure
      <$> (o .:? "res")
      <*> (o .:? "type")
      <*> (o .:? "rain_60min")
      <*> (o .:? "rain_24h")
      <*> (o .:? "rain_live")
      <*> (o .:? "rain_utc")
      <*> (o .:? "wind_strength")
      <*> (o .:? "wind_angle")
      <*> (o .:? "gust_strength")
      <*> (o .:? "gust_angle")
      <*> (o .:? "wind_timeutc&quot;")

-- | ToJSON NAMeasure
instance A.ToJSON NAMeasure where
  toJSON NAMeasure {..} =
   _omitNulls
      [ "res" .= nAMeasureRes
      , "type" .= nAMeasureType
      , "rain_60min" .= nAMeasureRain60min
      , "rain_24h" .= nAMeasureRain24h
      , "rain_live" .= nAMeasureRainLive
      , "rain_utc" .= nAMeasureRainUtc
      , "wind_strength" .= nAMeasureWindStrength
      , "wind_angle" .= nAMeasureWindAngle
      , "gust_strength" .= nAMeasureGustStrength
      , "gust_angle" .= nAMeasureGustAngle
      , "wind_timeutc&quot;" .= nAMeasureWindTimeutc
      ]


-- | Construct a value of type 'NAMeasure' (by applying it's required fields, if any)
mkNAMeasure
  :: NAMeasure
mkNAMeasure =
  NAMeasure
  { nAMeasureRes = Nothing
  , nAMeasureType = Nothing
  , nAMeasureRain60min = Nothing
  , nAMeasureRain24h = Nothing
  , nAMeasureRainLive = Nothing
  , nAMeasureRainUtc = Nothing
  , nAMeasureWindStrength = Nothing
  , nAMeasureWindAngle = Nothing
  , nAMeasureGustStrength = Nothing
  , nAMeasureGustAngle = Nothing
  , nAMeasureWindTimeutc = Nothing
  }

-- ** NAMeasureBodyElem
-- | NAMeasureBodyElem
data NAMeasureBodyElem = NAMeasureBodyElem
  { nAMeasureBodyElemBegTime :: !(Maybe Int) -- ^ "beg_time"
  , nAMeasureBodyElemStepTime :: !(Maybe Int) -- ^ "step_time"
  , nAMeasureBodyElemValue :: !(Maybe [[Float]]) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAMeasureBodyElem
instance A.FromJSON NAMeasureBodyElem where
  parseJSON = A.withObject "NAMeasureBodyElem" $ \o ->
    NAMeasureBodyElem
      <$> (o .:? "beg_time")
      <*> (o .:? "step_time")
      <*> (o .:? "value")

-- | ToJSON NAMeasureBodyElem
instance A.ToJSON NAMeasureBodyElem where
  toJSON NAMeasureBodyElem {..} =
   _omitNulls
      [ "beg_time" .= nAMeasureBodyElemBegTime
      , "step_time" .= nAMeasureBodyElemStepTime
      , "value" .= nAMeasureBodyElemValue
      ]


-- | Construct a value of type 'NAMeasureBodyElem' (by applying it's required fields, if any)
mkNAMeasureBodyElem
  :: NAMeasureBodyElem
mkNAMeasureBodyElem =
  NAMeasureBodyElem
  { nAMeasureBodyElemBegTime = Nothing
  , nAMeasureBodyElemStepTime = Nothing
  , nAMeasureBodyElemValue = Nothing
  }

-- ** NAMeasureResponse
-- | NAMeasureResponse
data NAMeasureResponse = NAMeasureResponse
  { nAMeasureResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAMeasureResponseBody :: !(Maybe [NAMeasureBodyElem]) -- ^ "body"
  , nAMeasureResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAMeasureResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAMeasureResponse
instance A.FromJSON NAMeasureResponse where
  parseJSON = A.withObject "NAMeasureResponse" $ \o ->
    NAMeasureResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAMeasureResponse
instance A.ToJSON NAMeasureResponse where
  toJSON NAMeasureResponse {..} =
   _omitNulls
      [ "status" .= nAMeasureResponseStatus
      , "body" .= nAMeasureResponseBody
      , "time_exec" .= nAMeasureResponseTimeExec
      , "time_server" .= nAMeasureResponseTimeServer
      ]


-- | Construct a value of type 'NAMeasureResponse' (by applying it's required fields, if any)
mkNAMeasureResponse
  :: NAMeasureResponse
mkNAMeasureResponse =
  NAMeasureResponse
  { nAMeasureResponseStatus = Nothing
  , nAMeasureResponseBody = Nothing
  , nAMeasureResponseTimeExec = Nothing
  , nAMeasureResponseTimeServer = Nothing
  }

-- ** NAModule
-- | NAModule
data NAModule = NAModule
  { nAModuleId :: !(Maybe Text) -- ^ "_id"
  , nAModuleDateSetup :: !(Maybe NADate) -- ^ "date_setup"
  , nAModuleFirmware :: !(Maybe Int) -- ^ "firmware"
  , nAModuleType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nAModuleModuleName :: !(Maybe Text) -- ^ "module_name"
  , nAModuleMainDevice :: !(Maybe Text) -- ^ "main_device"
  , nAModuleLastMessage :: !(Maybe Int) -- ^ "last_message"
  , nAModuleLastSeen :: !(Maybe Int) -- ^ "last_seen"
  , nAModulePublicExtData :: !(Maybe Bool) -- ^ "public_ext_data"
  , nAModuleRfStatus :: !(Maybe Int) -- ^ "rf_status" - \&quot;It contains the current radio status. The different thresholds to take into account are :\&quot; | RADIO_THRESHOLD_SIGNAL_LOW &#x3D; 90  RADIO_THRESHOLD_SIGNAL_MEDIUM &#x3D; 80 RADIO_THRESHOLD_SIGNAL_HIGH &#x3D; 70 RADIO_THRESHOLD_SIGNAL_FULL &#x3D; 60 
  , nAModuleBatteryVp :: !(Maybe Int) -- ^ "battery_vp" - It contains the current battery status. The threshold depends on the kind of module, below is the list of the different threshold to take into account according the module type. \&quot;Indoor module Battery range: 6000 ... 4200\&quot; | INDOOR_BATTERY_LEVEL_FULL &#x3D; 5640 INDOOR_BATTERY_LEVEL_HIGH &#x3D; 5280 INDOOR_BATTERY_LEVEL_MEDIUM &#x3D; 4920 INDOOR_BATTERY_LEVEL_LOW &#x3D; 4560 \&quot;Below 4560: very low\&quot; |      \&quot;Raingauge and outdoor module Battery range: 6000 ... 3600\&quot; | BATTERY_LEVEL_FULL &#x3D; 5500 BATTERY_LEVEL_HIGH &#x3D; 5000 BATTERY_LEVEL_MEDIUM &#x3D; 4500 BATTERY_LEVEL_LOW &#x3D; 4000 \&quot;Below 4000: very low\&quot; |      \&quot;Thermostat Battery range: 4500 ... 3000\&quot; | THERMOSTAT_BATTERY_LEVEL_FULL &#x3D; 4100 THERMOSTAT_BATTERY_LEVEL_HIGH &#x3D; 3600 THERMOSTAT_BATTERY_LEVEL_MEDIUM &#x3D; 3300 THERMOSTAT_BATTERY_LEVEL_LOW &#x3D; 3000 \&quot;Below 3000: very low\&quot; 
  , nAModuleBatteryPercent :: !(Maybe Int) -- ^ "battery_percent" - It contains the current battery level in percentage.
  , nAModuleThermOrientation :: !(Maybe Int) -- ^ "therm_orientation"
  , nAModuleThermRelayCmd :: !(Maybe Int) -- ^ "therm_relay_cmd"
  , nAModuleDashboardData :: !(Maybe NADashboardData) -- ^ "dashboard_data"
  , nAModuleDataType :: !(Maybe [Text]) -- ^ "data_type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAModule
instance A.FromJSON NAModule where
  parseJSON = A.withObject "NAModule" $ \o ->
    NAModule
      <$> (o .:? "_id")
      <*> (o .:? "date_setup")
      <*> (o .:? "firmware")
      <*> (o .:? "type")
      <*> (o .:? "module_name")
      <*> (o .:? "main_device")
      <*> (o .:? "last_message")
      <*> (o .:? "last_seen")
      <*> (o .:? "public_ext_data")
      <*> (o .:? "rf_status")
      <*> (o .:? "battery_vp")
      <*> (o .:? "battery_percent")
      <*> (o .:? "therm_orientation")
      <*> (o .:? "therm_relay_cmd")
      <*> (o .:? "dashboard_data")
      <*> (o .:? "data_type")

-- | ToJSON NAModule
instance A.ToJSON NAModule where
  toJSON NAModule {..} =
   _omitNulls
      [ "_id" .= nAModuleId
      , "date_setup" .= nAModuleDateSetup
      , "firmware" .= nAModuleFirmware
      , "type" .= nAModuleType
      , "module_name" .= nAModuleModuleName
      , "main_device" .= nAModuleMainDevice
      , "last_message" .= nAModuleLastMessage
      , "last_seen" .= nAModuleLastSeen
      , "public_ext_data" .= nAModulePublicExtData
      , "rf_status" .= nAModuleRfStatus
      , "battery_vp" .= nAModuleBatteryVp
      , "battery_percent" .= nAModuleBatteryPercent
      , "therm_orientation" .= nAModuleThermOrientation
      , "therm_relay_cmd" .= nAModuleThermRelayCmd
      , "dashboard_data" .= nAModuleDashboardData
      , "data_type" .= nAModuleDataType
      ]


-- | Construct a value of type 'NAModule' (by applying it's required fields, if any)
mkNAModule
  :: NAModule
mkNAModule =
  NAModule
  { nAModuleId = Nothing
  , nAModuleDateSetup = Nothing
  , nAModuleFirmware = Nothing
  , nAModuleType = Nothing
  , nAModuleModuleName = Nothing
  , nAModuleMainDevice = Nothing
  , nAModuleLastMessage = Nothing
  , nAModuleLastSeen = Nothing
  , nAModulePublicExtData = Nothing
  , nAModuleRfStatus = Nothing
  , nAModuleBatteryVp = Nothing
  , nAModuleBatteryPercent = Nothing
  , nAModuleThermOrientation = Nothing
  , nAModuleThermRelayCmd = Nothing
  , nAModuleDashboardData = Nothing
  , nAModuleDataType = Nothing
  }

-- ** NANewScheduleBody
-- | NANewScheduleBody
data NANewScheduleBody = NANewScheduleBody
  { nANewScheduleBodyScheduleId :: !(Maybe Text) -- ^ "schedule_id" - Id of the schedule. It can be use with the method \&quot;switchschedule\&quot;  
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NANewScheduleBody
instance A.FromJSON NANewScheduleBody where
  parseJSON = A.withObject "NANewScheduleBody" $ \o ->
    NANewScheduleBody
      <$> (o .:? "schedule_id")

-- | ToJSON NANewScheduleBody
instance A.ToJSON NANewScheduleBody where
  toJSON NANewScheduleBody {..} =
   _omitNulls
      [ "schedule_id" .= nANewScheduleBodyScheduleId
      ]


-- | Construct a value of type 'NANewScheduleBody' (by applying it's required fields, if any)
mkNANewScheduleBody
  :: NANewScheduleBody
mkNANewScheduleBody =
  NANewScheduleBody
  { nANewScheduleBodyScheduleId = Nothing
  }

-- ** NANewScheduleResponse
-- | NANewScheduleResponse
data NANewScheduleResponse = NANewScheduleResponse
  { nANewScheduleResponseStatus :: !(Maybe Text) -- ^ "status"
  , nANewScheduleResponseBody :: !(Maybe NANewScheduleBody) -- ^ "body"
  , nANewScheduleResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nANewScheduleResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NANewScheduleResponse
instance A.FromJSON NANewScheduleResponse where
  parseJSON = A.withObject "NANewScheduleResponse" $ \o ->
    NANewScheduleResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NANewScheduleResponse
instance A.ToJSON NANewScheduleResponse where
  toJSON NANewScheduleResponse {..} =
   _omitNulls
      [ "status" .= nANewScheduleResponseStatus
      , "body" .= nANewScheduleResponseBody
      , "time_exec" .= nANewScheduleResponseTimeExec
      , "time_server" .= nANewScheduleResponseTimeServer
      ]


-- | Construct a value of type 'NANewScheduleResponse' (by applying it's required fields, if any)
mkNANewScheduleResponse
  :: NANewScheduleResponse
mkNANewScheduleResponse =
  NANewScheduleResponse
  { nANewScheduleResponseStatus = Nothing
  , nANewScheduleResponseBody = Nothing
  , nANewScheduleResponseTimeExec = Nothing
  , nANewScheduleResponseTimeServer = Nothing
  }

-- ** NAObject
-- | NAObject
data NAObject = NAObject
  { nAObjectId :: !(Maybe Text) -- ^ "$id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAObject
instance A.FromJSON NAObject where
  parseJSON = A.withObject "NAObject" $ \o ->
    NAObject
      <$> (o .:? "$id")

-- | ToJSON NAObject
instance A.ToJSON NAObject where
  toJSON NAObject {..} =
   _omitNulls
      [ "$id" .= nAObjectId
      ]


-- | Construct a value of type 'NAObject' (by applying it's required fields, if any)
mkNAObject
  :: NAObject
mkNAObject =
  NAObject
  { nAObjectId = Nothing
  }

-- ** NAOkResponse
-- | NAOkResponse
data NAOkResponse = NAOkResponse
  { nAOkResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAOkResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAOkResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  , nAOkResponseBody :: !(Maybe Text) -- ^ "body"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAOkResponse
instance A.FromJSON NAOkResponse where
  parseJSON = A.withObject "NAOkResponse" $ \o ->
    NAOkResponse
      <$> (o .:? "status")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")
      <*> (o .:? "body")

-- | ToJSON NAOkResponse
instance A.ToJSON NAOkResponse where
  toJSON NAOkResponse {..} =
   _omitNulls
      [ "status" .= nAOkResponseStatus
      , "time_exec" .= nAOkResponseTimeExec
      , "time_server" .= nAOkResponseTimeServer
      , "body" .= nAOkResponseBody
      ]


-- | Construct a value of type 'NAOkResponse' (by applying it's required fields, if any)
mkNAOkResponse
  :: NAOkResponse
mkNAOkResponse =
  NAOkResponse
  { nAOkResponseStatus = Nothing
  , nAOkResponseTimeExec = Nothing
  , nAOkResponseTimeServer = Nothing
  , nAOkResponseBody = Nothing
  }

-- ** NAPartnerDevicesResponse
-- | NAPartnerDevicesResponse
data NAPartnerDevicesResponse = NAPartnerDevicesResponse
  { nAPartnerDevicesResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAPartnerDevicesResponseBody :: !(Maybe [Text]) -- ^ "body"
  , nAPartnerDevicesResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAPartnerDevicesResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPartnerDevicesResponse
instance A.FromJSON NAPartnerDevicesResponse where
  parseJSON = A.withObject "NAPartnerDevicesResponse" $ \o ->
    NAPartnerDevicesResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAPartnerDevicesResponse
instance A.ToJSON NAPartnerDevicesResponse where
  toJSON NAPartnerDevicesResponse {..} =
   _omitNulls
      [ "status" .= nAPartnerDevicesResponseStatus
      , "body" .= nAPartnerDevicesResponseBody
      , "time_exec" .= nAPartnerDevicesResponseTimeExec
      , "time_server" .= nAPartnerDevicesResponseTimeServer
      ]


-- | Construct a value of type 'NAPartnerDevicesResponse' (by applying it's required fields, if any)
mkNAPartnerDevicesResponse
  :: NAPartnerDevicesResponse
mkNAPartnerDevicesResponse =
  NAPartnerDevicesResponse
  { nAPartnerDevicesResponseStatus = Nothing
  , nAPartnerDevicesResponseBody = Nothing
  , nAPartnerDevicesResponseTimeExec = Nothing
  , nAPartnerDevicesResponseTimeServer = Nothing
  }

-- ** NAPidAlgo
-- | NAPidAlgo
data NAPidAlgo = NAPidAlgo
  { nAPidAlgoGain :: !(Maybe Int) -- ^ "gain"
  , nAPidAlgoPeriod :: !(Maybe Int) -- ^ "period"
  , nAPidAlgoTd :: !(Maybe Int) -- ^ "td"
  , nAPidAlgoTi :: !(Maybe Int) -- ^ "ti"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPidAlgo
instance A.FromJSON NAPidAlgo where
  parseJSON = A.withObject "NAPidAlgo" $ \o ->
    NAPidAlgo
      <$> (o .:? "gain")
      <*> (o .:? "period")
      <*> (o .:? "td")
      <*> (o .:? "ti")

-- | ToJSON NAPidAlgo
instance A.ToJSON NAPidAlgo where
  toJSON NAPidAlgo {..} =
   _omitNulls
      [ "gain" .= nAPidAlgoGain
      , "period" .= nAPidAlgoPeriod
      , "td" .= nAPidAlgoTd
      , "ti" .= nAPidAlgoTi
      ]


-- | Construct a value of type 'NAPidAlgo' (by applying it's required fields, if any)
mkNAPidAlgo
  :: NAPidAlgo
mkNAPidAlgo =
  NAPidAlgo
  { nAPidAlgoGain = Nothing
  , nAPidAlgoPeriod = Nothing
  , nAPidAlgoTd = Nothing
  , nAPidAlgoTi = Nothing
  }

-- ** NAPlace
-- | NAPlace
data NAPlace = NAPlace
  { nAPlaceCity :: !(Maybe Text) -- ^ "city"
  , nAPlaceAltitude :: !(Maybe Float) -- ^ "altitude"
  , nAPlaceCountry :: !(Maybe Text) -- ^ "country"
  , nAPlaceFromIp :: !(Maybe Bool) -- ^ "from_ip"
  , nAPlaceImproveLocProposed :: !(Maybe Bool) -- ^ "improveLocProposed"
  , nAPlaceLocation :: !(Maybe [Double]) -- ^ "location"
  , nAPlaceTimezone :: !(Maybe Text) -- ^ "timezone"
  , nAPlaceTrustLocation :: !(Maybe Bool) -- ^ "trust_location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPlace
instance A.FromJSON NAPlace where
  parseJSON = A.withObject "NAPlace" $ \o ->
    NAPlace
      <$> (o .:? "city")
      <*> (o .:? "altitude")
      <*> (o .:? "country")
      <*> (o .:? "from_ip")
      <*> (o .:? "improveLocProposed")
      <*> (o .:? "location")
      <*> (o .:? "timezone")
      <*> (o .:? "trust_location")

-- | ToJSON NAPlace
instance A.ToJSON NAPlace where
  toJSON NAPlace {..} =
   _omitNulls
      [ "city" .= nAPlaceCity
      , "altitude" .= nAPlaceAltitude
      , "country" .= nAPlaceCountry
      , "from_ip" .= nAPlaceFromIp
      , "improveLocProposed" .= nAPlaceImproveLocProposed
      , "location" .= nAPlaceLocation
      , "timezone" .= nAPlaceTimezone
      , "trust_location" .= nAPlaceTrustLocation
      ]


-- | Construct a value of type 'NAPlace' (by applying it's required fields, if any)
mkNAPlace
  :: NAPlace
mkNAPlace =
  NAPlace
  { nAPlaceCity = Nothing
  , nAPlaceAltitude = Nothing
  , nAPlaceCountry = Nothing
  , nAPlaceFromIp = Nothing
  , nAPlaceImproveLocProposed = Nothing
  , nAPlaceLocation = Nothing
  , nAPlaceTimezone = Nothing
  , nAPlaceTrustLocation = Nothing
  }

-- ** NAPlug
-- | NAPlug
data NAPlug = NAPlug
  { nAPlugId :: !(Maybe Text) -- ^ "_id"
  , nAPlugFirmware :: !(Maybe Int) -- ^ "firmware"
  , nAPlugLastStatusStore :: !(Maybe Int) -- ^ "last_status_store"
  , nAPlugPlace :: !(Maybe NAPlace) -- ^ "place"
  , nAPlugStationName :: !(Maybe Text) -- ^ "station_name"
  , nAPlugType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nAPlugWifiStatus :: !(Maybe Int) -- ^ "wifi_status" - It contains the current wifi status. The different thresholds to take into account are RSSI_THRESHOLD_0 &#x3D; 86 bad signal RSSI_THRESHOLD_1 &#x3D; 71 middle quality signal RSSI_THRESHOLD_2 &#x3D; 56 good signal 
  , nAPlugPlugConnectedBoiler :: !(Maybe Int) -- ^ "plug_connected_boiler"
  , nAPlugUdpConn :: !(Maybe Bool) -- ^ "udp_conn"
  , nAPlugLastPlugSeen :: !(Maybe Int) -- ^ "last_plug_seen"
  , nAPlugLastBilan :: !(Maybe NAYearMonth) -- ^ "last_bilan"
  , nAPlugModules :: !(Maybe [NAThermostat]) -- ^ "modules"
  , nAPlugSyncing :: !(Maybe Bool) -- ^ "syncing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPlug
instance A.FromJSON NAPlug where
  parseJSON = A.withObject "NAPlug" $ \o ->
    NAPlug
      <$> (o .:? "_id")
      <*> (o .:? "firmware")
      <*> (o .:? "last_status_store")
      <*> (o .:? "place")
      <*> (o .:? "station_name")
      <*> (o .:? "type")
      <*> (o .:? "wifi_status")
      <*> (o .:? "plug_connected_boiler")
      <*> (o .:? "udp_conn")
      <*> (o .:? "last_plug_seen")
      <*> (o .:? "last_bilan")
      <*> (o .:? "modules")
      <*> (o .:? "syncing")

-- | ToJSON NAPlug
instance A.ToJSON NAPlug where
  toJSON NAPlug {..} =
   _omitNulls
      [ "_id" .= nAPlugId
      , "firmware" .= nAPlugFirmware
      , "last_status_store" .= nAPlugLastStatusStore
      , "place" .= nAPlugPlace
      , "station_name" .= nAPlugStationName
      , "type" .= nAPlugType
      , "wifi_status" .= nAPlugWifiStatus
      , "plug_connected_boiler" .= nAPlugPlugConnectedBoiler
      , "udp_conn" .= nAPlugUdpConn
      , "last_plug_seen" .= nAPlugLastPlugSeen
      , "last_bilan" .= nAPlugLastBilan
      , "modules" .= nAPlugModules
      , "syncing" .= nAPlugSyncing
      ]


-- | Construct a value of type 'NAPlug' (by applying it's required fields, if any)
mkNAPlug
  :: NAPlug
mkNAPlug =
  NAPlug
  { nAPlugId = Nothing
  , nAPlugFirmware = Nothing
  , nAPlugLastStatusStore = Nothing
  , nAPlugPlace = Nothing
  , nAPlugStationName = Nothing
  , nAPlugType = Nothing
  , nAPlugWifiStatus = Nothing
  , nAPlugPlugConnectedBoiler = Nothing
  , nAPlugUdpConn = Nothing
  , nAPlugLastPlugSeen = Nothing
  , nAPlugLastBilan = Nothing
  , nAPlugModules = Nothing
  , nAPlugSyncing = Nothing
  }

-- ** NAPublicData
-- | NAPublicData
data NAPublicData = NAPublicData
  { nAPublicDataId :: !(Maybe Text) -- ^ "_id" - id of the station
  , nAPublicDataPlace :: !(Maybe NAPlace) -- ^ "place"
  , nAPublicDataMark :: !(Maybe Int) -- ^ "mark"
  , nAPublicDataModules :: !(Maybe [Text]) -- ^ "modules"
  , nAPublicDataModuleTypes :: !(Maybe (Map.Map String Text)) -- ^ "module_types" - Latest measurements of the station, organized by module
  , nAPublicDataMeasures :: !(Maybe (Map.Map String NAMeasure)) -- ^ "measures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPublicData
instance A.FromJSON NAPublicData where
  parseJSON = A.withObject "NAPublicData" $ \o ->
    NAPublicData
      <$> (o .:? "_id")
      <*> (o .:? "place")
      <*> (o .:? "mark")
      <*> (o .:? "modules")
      <*> (o .:? "module_types")
      <*> (o .:? "measures")

-- | ToJSON NAPublicData
instance A.ToJSON NAPublicData where
  toJSON NAPublicData {..} =
   _omitNulls
      [ "_id" .= nAPublicDataId
      , "place" .= nAPublicDataPlace
      , "mark" .= nAPublicDataMark
      , "modules" .= nAPublicDataModules
      , "module_types" .= nAPublicDataModuleTypes
      , "measures" .= nAPublicDataMeasures
      ]


-- | Construct a value of type 'NAPublicData' (by applying it's required fields, if any)
mkNAPublicData
  :: NAPublicData
mkNAPublicData =
  NAPublicData
  { nAPublicDataId = Nothing
  , nAPublicDataPlace = Nothing
  , nAPublicDataMark = Nothing
  , nAPublicDataModules = Nothing
  , nAPublicDataModuleTypes = Nothing
  , nAPublicDataMeasures = Nothing
  }

-- ** NAPublicDataResponse
-- | NAPublicDataResponse
data NAPublicDataResponse = NAPublicDataResponse
  { nAPublicDataResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAPublicDataResponseBody :: !(Maybe [NAPublicData]) -- ^ "body"
  , nAPublicDataResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAPublicDataResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAPublicDataResponse
instance A.FromJSON NAPublicDataResponse where
  parseJSON = A.withObject "NAPublicDataResponse" $ \o ->
    NAPublicDataResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAPublicDataResponse
instance A.ToJSON NAPublicDataResponse where
  toJSON NAPublicDataResponse {..} =
   _omitNulls
      [ "status" .= nAPublicDataResponseStatus
      , "body" .= nAPublicDataResponseBody
      , "time_exec" .= nAPublicDataResponseTimeExec
      , "time_server" .= nAPublicDataResponseTimeServer
      ]


-- | Construct a value of type 'NAPublicDataResponse' (by applying it's required fields, if any)
mkNAPublicDataResponse
  :: NAPublicDataResponse
mkNAPublicDataResponse =
  NAPublicDataResponse
  { nAPublicDataResponseStatus = Nothing
  , nAPublicDataResponseBody = Nothing
  , nAPublicDataResponseTimeExec = Nothing
  , nAPublicDataResponseTimeServer = Nothing
  }

-- ** NASetpoint
-- | NASetpoint
data NASetpoint = NASetpoint
  { nASetpointSetpointTemp :: !(Maybe Float) -- ^ "setpoint_temp"
  , nASetpointSetpointEndtime :: !(Maybe Int) -- ^ "setpoint_endtime"
  , nASetpointSetpointMode :: !(Maybe Text) -- ^ "setpoint_mode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NASetpoint
instance A.FromJSON NASetpoint where
  parseJSON = A.withObject "NASetpoint" $ \o ->
    NASetpoint
      <$> (o .:? "setpoint_temp")
      <*> (o .:? "setpoint_endtime")
      <*> (o .:? "setpoint_mode")

-- | ToJSON NASetpoint
instance A.ToJSON NASetpoint where
  toJSON NASetpoint {..} =
   _omitNulls
      [ "setpoint_temp" .= nASetpointSetpointTemp
      , "setpoint_endtime" .= nASetpointSetpointEndtime
      , "setpoint_mode" .= nASetpointSetpointMode
      ]


-- | Construct a value of type 'NASetpoint' (by applying it's required fields, if any)
mkNASetpoint
  :: NASetpoint
mkNASetpoint =
  NASetpoint
  { nASetpointSetpointTemp = Nothing
  , nASetpointSetpointEndtime = Nothing
  , nASetpointSetpointMode = Nothing
  }

-- ** NASetpointLog
-- | NASetpointLog
data NASetpointLog = NASetpointLog
  { nASetpointLogSetpoint :: !(Maybe NASetpoint) -- ^ "setpoint"
  , nASetpointLogTimestamp :: !(Maybe Integer) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NASetpointLog
instance A.FromJSON NASetpointLog where
  parseJSON = A.withObject "NASetpointLog" $ \o ->
    NASetpointLog
      <$> (o .:? "setpoint")
      <*> (o .:? "timestamp")

-- | ToJSON NASetpointLog
instance A.ToJSON NASetpointLog where
  toJSON NASetpointLog {..} =
   _omitNulls
      [ "setpoint" .= nASetpointLogSetpoint
      , "timestamp" .= nASetpointLogTimestamp
      ]


-- | Construct a value of type 'NASetpointLog' (by applying it's required fields, if any)
mkNASetpointLog
  :: NASetpointLog
mkNASetpointLog =
  NASetpointLog
  { nASetpointLogSetpoint = Nothing
  , nASetpointLogTimestamp = Nothing
  }

-- ** NASimpleAlgo
-- | NASimpleAlgo
data NASimpleAlgo = NASimpleAlgo
  { nASimpleAlgoHighDeadband :: !(Maybe Int) -- ^ "high_deadband"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NASimpleAlgo
instance A.FromJSON NASimpleAlgo where
  parseJSON = A.withObject "NASimpleAlgo" $ \o ->
    NASimpleAlgo
      <$> (o .:? "high_deadband")

-- | ToJSON NASimpleAlgo
instance A.ToJSON NASimpleAlgo where
  toJSON NASimpleAlgo {..} =
   _omitNulls
      [ "high_deadband" .= nASimpleAlgoHighDeadband
      ]


-- | Construct a value of type 'NASimpleAlgo' (by applying it's required fields, if any)
mkNASimpleAlgo
  :: NASimpleAlgo
mkNASimpleAlgo =
  NASimpleAlgo
  { nASimpleAlgoHighDeadband = Nothing
  }

-- ** NAStation
-- | NAStation
data NAStation = NAStation
  { nAStationLagDown :: !(Maybe Int) -- ^ "lag_down"
  , nAStationLagUp :: !(Maybe Int) -- ^ "lag_up"
  , nAStationOffOvershoot :: !(Maybe Float) -- ^ "off_overshoot"
  , nAStationOnOvershoot :: !(Maybe Float) -- ^ "on_overshoot"
  , nAStationPk :: !(Maybe Int) -- ^ "pk"
  , nAStationTau :: !(Maybe Int) -- ^ "tau"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAStation
instance A.FromJSON NAStation where
  parseJSON = A.withObject "NAStation" $ \o ->
    NAStation
      <$> (o .:? "lag_down")
      <*> (o .:? "lag_up")
      <*> (o .:? "off_overshoot")
      <*> (o .:? "on_overshoot")
      <*> (o .:? "pk")
      <*> (o .:? "tau")

-- | ToJSON NAStation
instance A.ToJSON NAStation where
  toJSON NAStation {..} =
   _omitNulls
      [ "lag_down" .= nAStationLagDown
      , "lag_up" .= nAStationLagUp
      , "off_overshoot" .= nAStationOffOvershoot
      , "on_overshoot" .= nAStationOnOvershoot
      , "pk" .= nAStationPk
      , "tau" .= nAStationTau
      ]


-- | Construct a value of type 'NAStation' (by applying it's required fields, if any)
mkNAStation
  :: NAStation
mkNAStation =
  NAStation
  { nAStationLagDown = Nothing
  , nAStationLagUp = Nothing
  , nAStationOffOvershoot = Nothing
  , nAStationOnOvershoot = Nothing
  , nAStationPk = Nothing
  , nAStationTau = Nothing
  }

-- ** NAStationDataBody
-- | NAStationDataBody
data NAStationDataBody = NAStationDataBody
  { nAStationDataBodyDevices :: !(Maybe [NAMain]) -- ^ "devices"
  , nAStationDataBodyUser :: !(Maybe NAUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAStationDataBody
instance A.FromJSON NAStationDataBody where
  parseJSON = A.withObject "NAStationDataBody" $ \o ->
    NAStationDataBody
      <$> (o .:? "devices")
      <*> (o .:? "user")

-- | ToJSON NAStationDataBody
instance A.ToJSON NAStationDataBody where
  toJSON NAStationDataBody {..} =
   _omitNulls
      [ "devices" .= nAStationDataBodyDevices
      , "user" .= nAStationDataBodyUser
      ]


-- | Construct a value of type 'NAStationDataBody' (by applying it's required fields, if any)
mkNAStationDataBody
  :: NAStationDataBody
mkNAStationDataBody =
  NAStationDataBody
  { nAStationDataBodyDevices = Nothing
  , nAStationDataBodyUser = Nothing
  }

-- ** NAStationDataResponse
-- | NAStationDataResponse
data NAStationDataResponse = NAStationDataResponse
  { nAStationDataResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAStationDataResponseBody :: !(Maybe NAStationDataBody) -- ^ "body"
  , nAStationDataResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAStationDataResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAStationDataResponse
instance A.FromJSON NAStationDataResponse where
  parseJSON = A.withObject "NAStationDataResponse" $ \o ->
    NAStationDataResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAStationDataResponse
instance A.ToJSON NAStationDataResponse where
  toJSON NAStationDataResponse {..} =
   _omitNulls
      [ "status" .= nAStationDataResponseStatus
      , "body" .= nAStationDataResponseBody
      , "time_exec" .= nAStationDataResponseTimeExec
      , "time_server" .= nAStationDataResponseTimeServer
      ]


-- | Construct a value of type 'NAStationDataResponse' (by applying it's required fields, if any)
mkNAStationDataResponse
  :: NAStationDataResponse
mkNAStationDataResponse =
  NAStationDataResponse
  { nAStationDataResponseStatus = Nothing
  , nAStationDataResponseBody = Nothing
  , nAStationDataResponseTimeExec = Nothing
  , nAStationDataResponseTimeServer = Nothing
  }

-- ** NAStationModule
-- | NAStationModule
data NAStationModule = NAStationModule
  { nAStationModuleId :: !(Maybe Text) -- ^ "_id"
  , nAStationModuleType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nAStationModuleLastMessage :: !(Maybe Int) -- ^ "last_message"
  , nAStationModuleLastSeen :: !(Maybe Int) -- ^ "last_seen"
  , nAStationModuleDashboardData :: !(Maybe NADashboardData) -- ^ "dashboard_data"
  , nAStationModuleDataType :: !(Maybe [Text]) -- ^ "data_type"
  , nAStationModuleModuleName :: !(Maybe Text) -- ^ "module_name"
  , nAStationModuleLastSetup :: !(Maybe Int) -- ^ "last_setup"
  , nAStationModuleBatteryVp :: !(Maybe Int) -- ^ "battery_vp" - It contains the current battery status. The threshold depends on the kind of module, below is the list of the different threshold to take into account according the module type. \&quot;Indoor module Battery range: 6000 ... 4200\&quot; | INDOOR_BATTERY_LEVEL_FULL &#x3D; 5640 INDOOR_BATTERY_LEVEL_HIGH &#x3D; 5280 INDOOR_BATTERY_LEVEL_MEDIUM &#x3D; 4920 INDOOR_BATTERY_LEVEL_LOW &#x3D; 4560 \&quot;Below 4560: very low\&quot; |      \&quot;Raingauge and outdoor module Battery range: 6000 ... 3600\&quot; | BATTERY_LEVEL_FULL &#x3D; 5500 BATTERY_LEVEL_HIGH &#x3D; 5000 BATTERY_LEVEL_MEDIUM &#x3D; 4500 BATTERY_LEVEL_LOW &#x3D; 4000 \&quot;Below 4000: very low\&quot; |      \&quot;Thermostat Battery range: 4500 ... 3000\&quot; | THERMOSTAT_BATTERY_LEVEL_FULL &#x3D; 4100 THERMOSTAT_BATTERY_LEVEL_HIGH &#x3D; 3600 THERMOSTAT_BATTERY_LEVEL_MEDIUM &#x3D; 3300 THERMOSTAT_BATTERY_LEVEL_LOW &#x3D; 3000 \&quot;Below 3000: very low\&quot; 
  , nAStationModuleBatteryPercent :: !(Maybe Int) -- ^ "battery_percent" - It contains the current battery level in percentage.
  , nAStationModuleRfStatus :: !(Maybe Int) -- ^ "rf_status" - \&quot;It contains the current radio status. The different thresholds to take into account are :\&quot; | RADIO_THRESHOLD_SIGNAL_LOW &#x3D; 90  RADIO_THRESHOLD_SIGNAL_MEDIUM &#x3D; 80 RADIO_THRESHOLD_SIGNAL_HIGH &#x3D; 70 RADIO_THRESHOLD_SIGNAL_FULL &#x3D; 60 
  , nAStationModuleFirmware :: !(Maybe Int) -- ^ "firmware"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAStationModule
instance A.FromJSON NAStationModule where
  parseJSON = A.withObject "NAStationModule" $ \o ->
    NAStationModule
      <$> (o .:? "_id")
      <*> (o .:? "type")
      <*> (o .:? "last_message")
      <*> (o .:? "last_seen")
      <*> (o .:? "dashboard_data")
      <*> (o .:? "data_type")
      <*> (o .:? "module_name")
      <*> (o .:? "last_setup")
      <*> (o .:? "battery_vp")
      <*> (o .:? "battery_percent")
      <*> (o .:? "rf_status")
      <*> (o .:? "firmware")

-- | ToJSON NAStationModule
instance A.ToJSON NAStationModule where
  toJSON NAStationModule {..} =
   _omitNulls
      [ "_id" .= nAStationModuleId
      , "type" .= nAStationModuleType
      , "last_message" .= nAStationModuleLastMessage
      , "last_seen" .= nAStationModuleLastSeen
      , "dashboard_data" .= nAStationModuleDashboardData
      , "data_type" .= nAStationModuleDataType
      , "module_name" .= nAStationModuleModuleName
      , "last_setup" .= nAStationModuleLastSetup
      , "battery_vp" .= nAStationModuleBatteryVp
      , "battery_percent" .= nAStationModuleBatteryPercent
      , "rf_status" .= nAStationModuleRfStatus
      , "firmware" .= nAStationModuleFirmware
      ]


-- | Construct a value of type 'NAStationModule' (by applying it's required fields, if any)
mkNAStationModule
  :: NAStationModule
mkNAStationModule =
  NAStationModule
  { nAStationModuleId = Nothing
  , nAStationModuleType = Nothing
  , nAStationModuleLastMessage = Nothing
  , nAStationModuleLastSeen = Nothing
  , nAStationModuleDashboardData = Nothing
  , nAStationModuleDataType = Nothing
  , nAStationModuleModuleName = Nothing
  , nAStationModuleLastSetup = Nothing
  , nAStationModuleBatteryVp = Nothing
  , nAStationModuleBatteryPercent = Nothing
  , nAStationModuleRfStatus = Nothing
  , nAStationModuleFirmware = Nothing
  }

-- ** NAThermMeasure
-- | NAThermMeasure
data NAThermMeasure = NAThermMeasure
  { nAThermMeasureTime :: !(Maybe Int) -- ^ "time"
  , nAThermMeasureTemperature :: !(Maybe Float) -- ^ "temperature"
  , nAThermMeasureSetpointTemp :: !(Maybe Float) -- ^ "setpoint_temp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermMeasure
instance A.FromJSON NAThermMeasure where
  parseJSON = A.withObject "NAThermMeasure" $ \o ->
    NAThermMeasure
      <$> (o .:? "time")
      <*> (o .:? "temperature")
      <*> (o .:? "setpoint_temp")

-- | ToJSON NAThermMeasure
instance A.ToJSON NAThermMeasure where
  toJSON NAThermMeasure {..} =
   _omitNulls
      [ "time" .= nAThermMeasureTime
      , "temperature" .= nAThermMeasureTemperature
      , "setpoint_temp" .= nAThermMeasureSetpointTemp
      ]


-- | Construct a value of type 'NAThermMeasure' (by applying it's required fields, if any)
mkNAThermMeasure
  :: NAThermMeasure
mkNAThermMeasure =
  NAThermMeasure
  { nAThermMeasureTime = Nothing
  , nAThermMeasureTemperature = Nothing
  , nAThermMeasureSetpointTemp = Nothing
  }

-- ** NAThermProgram
-- | NAThermProgram
data NAThermProgram = NAThermProgram
  { nAThermProgramProgramId :: !(Maybe Text) -- ^ "program_id"
  , nAThermProgramName :: !(Maybe Text) -- ^ "name"
  , nAThermProgramZones :: !(Maybe [NAZone]) -- ^ "zones"
  , nAThermProgramTimetable :: !(Maybe [NATimeTableItem]) -- ^ "timetable"
  , nAThermProgramSelected :: !(Maybe Bool) -- ^ "selected"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermProgram
instance A.FromJSON NAThermProgram where
  parseJSON = A.withObject "NAThermProgram" $ \o ->
    NAThermProgram
      <$> (o .:? "program_id")
      <*> (o .:? "name")
      <*> (o .:? "zones")
      <*> (o .:? "timetable")
      <*> (o .:? "selected")

-- | ToJSON NAThermProgram
instance A.ToJSON NAThermProgram where
  toJSON NAThermProgram {..} =
   _omitNulls
      [ "program_id" .= nAThermProgramProgramId
      , "name" .= nAThermProgramName
      , "zones" .= nAThermProgramZones
      , "timetable" .= nAThermProgramTimetable
      , "selected" .= nAThermProgramSelected
      ]


-- | Construct a value of type 'NAThermProgram' (by applying it's required fields, if any)
mkNAThermProgram
  :: NAThermProgram
mkNAThermProgram =
  NAThermProgram
  { nAThermProgramProgramId = Nothing
  , nAThermProgramName = Nothing
  , nAThermProgramZones = Nothing
  , nAThermProgramTimetable = Nothing
  , nAThermProgramSelected = Nothing
  }

-- ** NAThermStateBody
-- | NAThermStateBody
data NAThermStateBody = NAThermStateBody
  { nAThermStateBodySetpoint :: !(Maybe NASetpoint) -- ^ "setpoint"
  , nAThermStateBodySetpointOrder :: !(Maybe NASetpoint) -- ^ "setpoint_order"
  , nAThermStateBodyThermProgram :: !(Maybe NAThermProgram) -- ^ "therm_program"
  , nAThermStateBodyThermProgramBackup :: !(Maybe [NAThermProgram]) -- ^ "therm_program_backup"
  , nAThermStateBodyThermProgramOrder :: !(Maybe NAThermProgram) -- ^ "therm_program_order"
  , nAThermStateBodyThermOrientation :: !(Maybe Int) -- ^ "therm_orientation"
  , nAThermStateBodyThermRelayCmd :: !(Maybe Int) -- ^ "therm_relay_cmd"
  , nAThermStateBodyBatteryVp :: !(Maybe Int) -- ^ "battery_vp"
  , nAThermStateBodyBatteryPercent :: !(Maybe Int) -- ^ "battery_percent" - It contains the current battery level in percentage.
  , nAThermStateBodyRfStatus :: !(Maybe Int) -- ^ "rf_status"
  , nAThermStateBodyPlugConnectedBoiler :: !(Maybe Int) -- ^ "plug_connected_boiler"
  , nAThermStateBodyUdpConn :: !(Maybe Bool) -- ^ "udp_conn"
  , nAThermStateBodyLastThermSeen :: !(Maybe Int) -- ^ "last_therm_seen"
  , nAThermStateBodyLastPlugSeen :: !(Maybe Int) -- ^ "last_plug_seen"
  , nAThermStateBodyWifiStatus :: !(Maybe Int) -- ^ "wifi_status"
  , nAThermStateBodyMeasured :: !(Maybe NAThermMeasure) -- ^ "measured"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermStateBody
instance A.FromJSON NAThermStateBody where
  parseJSON = A.withObject "NAThermStateBody" $ \o ->
    NAThermStateBody
      <$> (o .:? "setpoint")
      <*> (o .:? "setpoint_order")
      <*> (o .:? "therm_program")
      <*> (o .:? "therm_program_backup")
      <*> (o .:? "therm_program_order")
      <*> (o .:? "therm_orientation")
      <*> (o .:? "therm_relay_cmd")
      <*> (o .:? "battery_vp")
      <*> (o .:? "battery_percent")
      <*> (o .:? "rf_status")
      <*> (o .:? "plug_connected_boiler")
      <*> (o .:? "udp_conn")
      <*> (o .:? "last_therm_seen")
      <*> (o .:? "last_plug_seen")
      <*> (o .:? "wifi_status")
      <*> (o .:? "measured")

-- | ToJSON NAThermStateBody
instance A.ToJSON NAThermStateBody where
  toJSON NAThermStateBody {..} =
   _omitNulls
      [ "setpoint" .= nAThermStateBodySetpoint
      , "setpoint_order" .= nAThermStateBodySetpointOrder
      , "therm_program" .= nAThermStateBodyThermProgram
      , "therm_program_backup" .= nAThermStateBodyThermProgramBackup
      , "therm_program_order" .= nAThermStateBodyThermProgramOrder
      , "therm_orientation" .= nAThermStateBodyThermOrientation
      , "therm_relay_cmd" .= nAThermStateBodyThermRelayCmd
      , "battery_vp" .= nAThermStateBodyBatteryVp
      , "battery_percent" .= nAThermStateBodyBatteryPercent
      , "rf_status" .= nAThermStateBodyRfStatus
      , "plug_connected_boiler" .= nAThermStateBodyPlugConnectedBoiler
      , "udp_conn" .= nAThermStateBodyUdpConn
      , "last_therm_seen" .= nAThermStateBodyLastThermSeen
      , "last_plug_seen" .= nAThermStateBodyLastPlugSeen
      , "wifi_status" .= nAThermStateBodyWifiStatus
      , "measured" .= nAThermStateBodyMeasured
      ]


-- | Construct a value of type 'NAThermStateBody' (by applying it's required fields, if any)
mkNAThermStateBody
  :: NAThermStateBody
mkNAThermStateBody =
  NAThermStateBody
  { nAThermStateBodySetpoint = Nothing
  , nAThermStateBodySetpointOrder = Nothing
  , nAThermStateBodyThermProgram = Nothing
  , nAThermStateBodyThermProgramBackup = Nothing
  , nAThermStateBodyThermProgramOrder = Nothing
  , nAThermStateBodyThermOrientation = Nothing
  , nAThermStateBodyThermRelayCmd = Nothing
  , nAThermStateBodyBatteryVp = Nothing
  , nAThermStateBodyBatteryPercent = Nothing
  , nAThermStateBodyRfStatus = Nothing
  , nAThermStateBodyPlugConnectedBoiler = Nothing
  , nAThermStateBodyUdpConn = Nothing
  , nAThermStateBodyLastThermSeen = Nothing
  , nAThermStateBodyLastPlugSeen = Nothing
  , nAThermStateBodyWifiStatus = Nothing
  , nAThermStateBodyMeasured = Nothing
  }

-- ** NAThermStateResponse
-- | NAThermStateResponse
data NAThermStateResponse = NAThermStateResponse
  { nAThermStateResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAThermStateResponseBody :: !(Maybe NAThermStateBody) -- ^ "body"
  , nAThermStateResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAThermStateResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermStateResponse
instance A.FromJSON NAThermStateResponse where
  parseJSON = A.withObject "NAThermStateResponse" $ \o ->
    NAThermStateResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAThermStateResponse
instance A.ToJSON NAThermStateResponse where
  toJSON NAThermStateResponse {..} =
   _omitNulls
      [ "status" .= nAThermStateResponseStatus
      , "body" .= nAThermStateResponseBody
      , "time_exec" .= nAThermStateResponseTimeExec
      , "time_server" .= nAThermStateResponseTimeServer
      ]


-- | Construct a value of type 'NAThermStateResponse' (by applying it's required fields, if any)
mkNAThermStateResponse
  :: NAThermStateResponse
mkNAThermStateResponse =
  NAThermStateResponse
  { nAThermStateResponseStatus = Nothing
  , nAThermStateResponseBody = Nothing
  , nAThermStateResponseTimeExec = Nothing
  , nAThermStateResponseTimeServer = Nothing
  }

-- ** NAThermostat
-- | NAThermostat
data NAThermostat = NAThermostat
  { nAThermostatId :: !(Maybe Text) -- ^ "_id"
  , nAThermostatFirmware :: !(Maybe Int) -- ^ "firmware"
  , nAThermostatType :: !(Maybe Text) -- ^ "type" - Included in every device or module. It defines the type of the device/module. Its values are among : NAMain : for the base station NAModule1 : for the outdoor module NAModule4 : for the additionnal indoor module NAModule3 : for the rain gauge module NAPlug : for the thermostat relay/plug NATherm1 : for the thermostat module 
  , nAThermostatModuleName :: !(Maybe Text) -- ^ "module_name"
  , nAThermostatLastMessage :: !(Maybe Int) -- ^ "last_message"
  , nAThermostatRfStatus :: !(Maybe Int) -- ^ "rf_status" - \&quot;It contains the current radio status. The different thresholds to take into account are :\&quot; | RADIO_THRESHOLD_SIGNAL_LOW &#x3D; 90  RADIO_THRESHOLD_SIGNAL_MEDIUM &#x3D; 80 RADIO_THRESHOLD_SIGNAL_HIGH &#x3D; 70 RADIO_THRESHOLD_SIGNAL_FULL &#x3D; 60 
  , nAThermostatBatteryVp :: !(Maybe Int) -- ^ "battery_vp" - It contains the current battery status. The threshold depends on the kind of module, below is the list of the different threshold to take into account according the module type. \&quot;Indoor module Battery range: 6000 ... 4200\&quot; | INDOOR_BATTERY_LEVEL_FULL &#x3D; 5640 INDOOR_BATTERY_LEVEL_HIGH &#x3D; 5280 INDOOR_BATTERY_LEVEL_MEDIUM &#x3D; 4920 INDOOR_BATTERY_LEVEL_LOW &#x3D; 4560 \&quot;Below 4560: very low\&quot; |      \&quot;Raingauge and outdoor module Battery range: 6000 ... 3600\&quot; | BATTERY_LEVEL_FULL &#x3D; 5500 BATTERY_LEVEL_HIGH &#x3D; 5000 BATTERY_LEVEL_MEDIUM &#x3D; 4500 BATTERY_LEVEL_LOW &#x3D; 4000 \&quot;Below 4000: very low\&quot; |      \&quot;Thermostat Battery range: 4500 ... 3000\&quot; | THERMOSTAT_BATTERY_LEVEL_FULL &#x3D; 4100 THERMOSTAT_BATTERY_LEVEL_HIGH &#x3D; 3600 THERMOSTAT_BATTERY_LEVEL_MEDIUM &#x3D; 3300 THERMOSTAT_BATTERY_LEVEL_LOW &#x3D; 3000 \&quot;Below 3000: very low\&quot; 
  , nAThermostatBatteryPercent :: !(Maybe Int) -- ^ "battery_percent" - It contains the current battery level in percentage.
  , nAThermostatSetpoint :: !(Maybe NASetpoint) -- ^ "setpoint"
  , nAThermostatSetpointOrder :: !(Maybe NASetpoint) -- ^ "setpoint_order"
  , nAThermostatThermOrientation :: !(Maybe Int) -- ^ "therm_orientation"
  , nAThermostatThermRelayCmd :: !(Maybe Int) -- ^ "therm_relay_cmd"
  , nAThermostatLastThermSeen :: !(Maybe Int) -- ^ "last_therm_seen"
  , nAThermostatMeasured :: !(Maybe NAThermMeasure) -- ^ "measured"
  , nAThermostatSetpointHistory :: !(Maybe [NASetpointLog]) -- ^ "setpoint_history" - The last 20 setpoints (mode, endtime, and timestamp) the thermostats has entered.
  , nAThermostatThermProgramList :: !(Maybe [NAThermProgram]) -- ^ "therm_program_list" - List of the weekly heating planning used by the thermostat
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermostat
instance A.FromJSON NAThermostat where
  parseJSON = A.withObject "NAThermostat" $ \o ->
    NAThermostat
      <$> (o .:? "_id")
      <*> (o .:? "firmware")
      <*> (o .:? "type")
      <*> (o .:? "module_name")
      <*> (o .:? "last_message")
      <*> (o .:? "rf_status")
      <*> (o .:? "battery_vp")
      <*> (o .:? "battery_percent")
      <*> (o .:? "setpoint")
      <*> (o .:? "setpoint_order")
      <*> (o .:? "therm_orientation")
      <*> (o .:? "therm_relay_cmd")
      <*> (o .:? "last_therm_seen")
      <*> (o .:? "measured")
      <*> (o .:? "setpoint_history")
      <*> (o .:? "therm_program_list")

-- | ToJSON NAThermostat
instance A.ToJSON NAThermostat where
  toJSON NAThermostat {..} =
   _omitNulls
      [ "_id" .= nAThermostatId
      , "firmware" .= nAThermostatFirmware
      , "type" .= nAThermostatType
      , "module_name" .= nAThermostatModuleName
      , "last_message" .= nAThermostatLastMessage
      , "rf_status" .= nAThermostatRfStatus
      , "battery_vp" .= nAThermostatBatteryVp
      , "battery_percent" .= nAThermostatBatteryPercent
      , "setpoint" .= nAThermostatSetpoint
      , "setpoint_order" .= nAThermostatSetpointOrder
      , "therm_orientation" .= nAThermostatThermOrientation
      , "therm_relay_cmd" .= nAThermostatThermRelayCmd
      , "last_therm_seen" .= nAThermostatLastThermSeen
      , "measured" .= nAThermostatMeasured
      , "setpoint_history" .= nAThermostatSetpointHistory
      , "therm_program_list" .= nAThermostatThermProgramList
      ]


-- | Construct a value of type 'NAThermostat' (by applying it's required fields, if any)
mkNAThermostat
  :: NAThermostat
mkNAThermostat =
  NAThermostat
  { nAThermostatId = Nothing
  , nAThermostatFirmware = Nothing
  , nAThermostatType = Nothing
  , nAThermostatModuleName = Nothing
  , nAThermostatLastMessage = Nothing
  , nAThermostatRfStatus = Nothing
  , nAThermostatBatteryVp = Nothing
  , nAThermostatBatteryPercent = Nothing
  , nAThermostatSetpoint = Nothing
  , nAThermostatSetpointOrder = Nothing
  , nAThermostatThermOrientation = Nothing
  , nAThermostatThermRelayCmd = Nothing
  , nAThermostatLastThermSeen = Nothing
  , nAThermostatMeasured = Nothing
  , nAThermostatSetpointHistory = Nothing
  , nAThermostatThermProgramList = Nothing
  }

-- ** NAThermostatDataBody
-- | NAThermostatDataBody
data NAThermostatDataBody = NAThermostatDataBody
  { nAThermostatDataBodyDevices :: !(Maybe [NAPlug]) -- ^ "devices"
  , nAThermostatDataBodyUser :: !(Maybe NAUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermostatDataBody
instance A.FromJSON NAThermostatDataBody where
  parseJSON = A.withObject "NAThermostatDataBody" $ \o ->
    NAThermostatDataBody
      <$> (o .:? "devices")
      <*> (o .:? "user")

-- | ToJSON NAThermostatDataBody
instance A.ToJSON NAThermostatDataBody where
  toJSON NAThermostatDataBody {..} =
   _omitNulls
      [ "devices" .= nAThermostatDataBodyDevices
      , "user" .= nAThermostatDataBodyUser
      ]


-- | Construct a value of type 'NAThermostatDataBody' (by applying it's required fields, if any)
mkNAThermostatDataBody
  :: NAThermostatDataBody
mkNAThermostatDataBody =
  NAThermostatDataBody
  { nAThermostatDataBodyDevices = Nothing
  , nAThermostatDataBodyUser = Nothing
  }

-- ** NAThermostatDataResponse
-- | NAThermostatDataResponse
data NAThermostatDataResponse = NAThermostatDataResponse
  { nAThermostatDataResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAThermostatDataResponseBody :: !(Maybe NAThermostatDataBody) -- ^ "body"
  , nAThermostatDataResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAThermostatDataResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAThermostatDataResponse
instance A.FromJSON NAThermostatDataResponse where
  parseJSON = A.withObject "NAThermostatDataResponse" $ \o ->
    NAThermostatDataResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAThermostatDataResponse
instance A.ToJSON NAThermostatDataResponse where
  toJSON NAThermostatDataResponse {..} =
   _omitNulls
      [ "status" .= nAThermostatDataResponseStatus
      , "body" .= nAThermostatDataResponseBody
      , "time_exec" .= nAThermostatDataResponseTimeExec
      , "time_server" .= nAThermostatDataResponseTimeServer
      ]


-- | Construct a value of type 'NAThermostatDataResponse' (by applying it's required fields, if any)
mkNAThermostatDataResponse
  :: NAThermostatDataResponse
mkNAThermostatDataResponse =
  NAThermostatDataResponse
  { nAThermostatDataResponseStatus = Nothing
  , nAThermostatDataResponseBody = Nothing
  , nAThermostatDataResponseTimeExec = Nothing
  , nAThermostatDataResponseTimeServer = Nothing
  }

-- ** NATimeTableItem
-- | NATimeTableItem
data NATimeTableItem = NATimeTableItem
  { nATimeTableItemId :: !(Maybe Int) -- ^ "id"
  , nATimeTableItemMOffset :: !(Maybe Int) -- ^ "m_offset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NATimeTableItem
instance A.FromJSON NATimeTableItem where
  parseJSON = A.withObject "NATimeTableItem" $ \o ->
    NATimeTableItem
      <$> (o .:? "id")
      <*> (o .:? "m_offset")

-- | ToJSON NATimeTableItem
instance A.ToJSON NATimeTableItem where
  toJSON NATimeTableItem {..} =
   _omitNulls
      [ "id" .= nATimeTableItemId
      , "m_offset" .= nATimeTableItemMOffset
      ]


-- | Construct a value of type 'NATimeTableItem' (by applying it's required fields, if any)
mkNATimeTableItem
  :: NATimeTableItem
mkNATimeTableItem =
  NATimeTableItem
  { nATimeTableItemId = Nothing
  , nATimeTableItemMOffset = Nothing
  }

-- ** NAUser
-- | NAUser
data NAUser = NAUser
  { nAUserId :: !(Maybe Text) -- ^ "_id"
  , nAUserAdministrative :: !(Maybe NAUserAdministrative) -- ^ "administrative"
  , nAUserDateCreation :: !(Maybe NADate) -- ^ "date_creation"
  , nAUserDevices :: !(Maybe [Text]) -- ^ "devices" - An array of string containing the ids of the devices owned by the user
  , nAUserFriendDevices :: !(Maybe [Text]) -- ^ "friend_devices" - An array of string containing the ids of the devices on which the user has a \&quot;guest\&quot; access 
  , nAUserMail :: !(Maybe Text) -- ^ "mail"
  , nAUserTimelineNotRead :: !(Maybe Int) -- ^ "timeline_not_read"
  , nAUserTimelineSize :: !(Maybe Int) -- ^ "timeline_size"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAUser
instance A.FromJSON NAUser where
  parseJSON = A.withObject "NAUser" $ \o ->
    NAUser
      <$> (o .:? "_id")
      <*> (o .:? "administrative")
      <*> (o .:? "date_creation")
      <*> (o .:? "devices")
      <*> (o .:? "friend_devices")
      <*> (o .:? "mail")
      <*> (o .:? "timeline_not_read")
      <*> (o .:? "timeline_size")

-- | ToJSON NAUser
instance A.ToJSON NAUser where
  toJSON NAUser {..} =
   _omitNulls
      [ "_id" .= nAUserId
      , "administrative" .= nAUserAdministrative
      , "date_creation" .= nAUserDateCreation
      , "devices" .= nAUserDevices
      , "friend_devices" .= nAUserFriendDevices
      , "mail" .= nAUserMail
      , "timeline_not_read" .= nAUserTimelineNotRead
      , "timeline_size" .= nAUserTimelineSize
      ]


-- | Construct a value of type 'NAUser' (by applying it's required fields, if any)
mkNAUser
  :: NAUser
mkNAUser =
  NAUser
  { nAUserId = Nothing
  , nAUserAdministrative = Nothing
  , nAUserDateCreation = Nothing
  , nAUserDevices = Nothing
  , nAUserFriendDevices = Nothing
  , nAUserMail = Nothing
  , nAUserTimelineNotRead = Nothing
  , nAUserTimelineSize = Nothing
  }

-- ** NAUserAdministrative
-- | NAUserAdministrative
data NAUserAdministrative = NAUserAdministrative
  { nAUserAdministrativeCountry :: !(Maybe Text) -- ^ "country" - user country
  , nAUserAdministrativeLang :: !(Maybe Text) -- ^ "lang" - user locale
  , nAUserAdministrativeRegLocale :: !(Maybe Text) -- ^ "reg_locale" - user regional preferences (used for displaying date)
  , nAUserAdministrativeUnit :: !(Maybe Text) -- ^ "unit" - 0 -&gt; metric system, 1 -&gt; imperial system
  , nAUserAdministrativeWindunit :: !(Maybe Text) -- ^ "windunit" - 0 -&gt; kph, 1 -&gt; mph, 2 -&gt; ms, 3 -&gt; beaufort, 4 -&gt; knot
  , nAUserAdministrativePressureunit :: !(Maybe Text) -- ^ "pressureunit" - 0 -&gt; mbar, 1 -&gt; inHg, 2 -&gt; mmHg
  , nAUserAdministrativeFeelLikeAlgo :: !(Maybe Text) -- ^ "feel_like_algo" - algorithm used to compute feel like temperature, 0 -&gt; humidex, 1 -&gt; heat-index
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAUserAdministrative
instance A.FromJSON NAUserAdministrative where
  parseJSON = A.withObject "NAUserAdministrative" $ \o ->
    NAUserAdministrative
      <$> (o .:? "country")
      <*> (o .:? "lang")
      <*> (o .:? "reg_locale")
      <*> (o .:? "unit")
      <*> (o .:? "windunit")
      <*> (o .:? "pressureunit")
      <*> (o .:? "feel_like_algo")

-- | ToJSON NAUserAdministrative
instance A.ToJSON NAUserAdministrative where
  toJSON NAUserAdministrative {..} =
   _omitNulls
      [ "country" .= nAUserAdministrativeCountry
      , "lang" .= nAUserAdministrativeLang
      , "reg_locale" .= nAUserAdministrativeRegLocale
      , "unit" .= nAUserAdministrativeUnit
      , "windunit" .= nAUserAdministrativeWindunit
      , "pressureunit" .= nAUserAdministrativePressureunit
      , "feel_like_algo" .= nAUserAdministrativeFeelLikeAlgo
      ]


-- | Construct a value of type 'NAUserAdministrative' (by applying it's required fields, if any)
mkNAUserAdministrative
  :: NAUserAdministrative
mkNAUserAdministrative =
  NAUserAdministrative
  { nAUserAdministrativeCountry = Nothing
  , nAUserAdministrativeLang = Nothing
  , nAUserAdministrativeRegLocale = Nothing
  , nAUserAdministrativeUnit = Nothing
  , nAUserAdministrativeWindunit = Nothing
  , nAUserAdministrativePressureunit = Nothing
  , nAUserAdministrativeFeelLikeAlgo = Nothing
  }

-- ** NAUserResponse
-- | NAUserResponse
data NAUserResponse = NAUserResponse
  { nAUserResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAUserResponseBody :: !(Maybe NAUser) -- ^ "body"
  , nAUserResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAUserResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAUserResponse
instance A.FromJSON NAUserResponse where
  parseJSON = A.withObject "NAUserResponse" $ \o ->
    NAUserResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAUserResponse
instance A.ToJSON NAUserResponse where
  toJSON NAUserResponse {..} =
   _omitNulls
      [ "status" .= nAUserResponseStatus
      , "body" .= nAUserResponseBody
      , "time_exec" .= nAUserResponseTimeExec
      , "time_server" .= nAUserResponseTimeServer
      ]


-- | Construct a value of type 'NAUserResponse' (by applying it's required fields, if any)
mkNAUserResponse
  :: NAUserResponse
mkNAUserResponse =
  NAUserResponse
  { nAUserResponseStatus = Nothing
  , nAUserResponseBody = Nothing
  , nAUserResponseTimeExec = Nothing
  , nAUserResponseTimeServer = Nothing
  }

-- ** NAWelcomeCamera
-- | NAWelcomeCamera
data NAWelcomeCamera = NAWelcomeCamera
  { nAWelcomeCameraId :: !(Maybe Text) -- ^ "id" - Id of the camera
  , nAWelcomeCameraType :: !(Maybe Text) -- ^ "type" - Type of the camera
  , nAWelcomeCameraStatus :: !(Maybe Text) -- ^ "status" - If camera is monitoring (on/off)
  , nAWelcomeCameraVpnUrl :: !(Maybe Text) -- ^ "vpn_url" - Only for scope access_camera. Address of the camera
  , nAWelcomeCameraIsLocal :: !(Maybe Bool) -- ^ "is_local" - Only for scope access_camera. If Camera and application requesting the information are on the same IP (true/false)
  , nAWelcomeCameraSdStatus :: !(Maybe Text) -- ^ "sd_status" - If SD card status is ok (on/off)
  , nAWelcomeCameraAlimStatus :: !(Maybe Text) -- ^ "alim_status" - If power supply is ok (on/off)
  , nAWelcomeCameraName :: !(Maybe Text) -- ^ "name" - Name of the camera
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeCamera
instance A.FromJSON NAWelcomeCamera where
  parseJSON = A.withObject "NAWelcomeCamera" $ \o ->
    NAWelcomeCamera
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "status")
      <*> (o .:? "vpn_url")
      <*> (o .:? "is_local")
      <*> (o .:? "sd_status")
      <*> (o .:? "alim_status")
      <*> (o .:? "name")

-- | ToJSON NAWelcomeCamera
instance A.ToJSON NAWelcomeCamera where
  toJSON NAWelcomeCamera {..} =
   _omitNulls
      [ "id" .= nAWelcomeCameraId
      , "type" .= nAWelcomeCameraType
      , "status" .= nAWelcomeCameraStatus
      , "vpn_url" .= nAWelcomeCameraVpnUrl
      , "is_local" .= nAWelcomeCameraIsLocal
      , "sd_status" .= nAWelcomeCameraSdStatus
      , "alim_status" .= nAWelcomeCameraAlimStatus
      , "name" .= nAWelcomeCameraName
      ]


-- | Construct a value of type 'NAWelcomeCamera' (by applying it's required fields, if any)
mkNAWelcomeCamera
  :: NAWelcomeCamera
mkNAWelcomeCamera =
  NAWelcomeCamera
  { nAWelcomeCameraId = Nothing
  , nAWelcomeCameraType = Nothing
  , nAWelcomeCameraStatus = Nothing
  , nAWelcomeCameraVpnUrl = Nothing
  , nAWelcomeCameraIsLocal = Nothing
  , nAWelcomeCameraSdStatus = Nothing
  , nAWelcomeCameraAlimStatus = Nothing
  , nAWelcomeCameraName = Nothing
  }

-- ** NAWelcomeEvent
-- | NAWelcomeEvent
data NAWelcomeEvent = NAWelcomeEvent
  { nAWelcomeEventId :: !(Maybe Text) -- ^ "id" - Identifier of the event
  , nAWelcomeEventType :: !(Maybe Text) -- ^ "type" - Type of events. Go to the Welcome page for further details.
  , nAWelcomeEventTime :: !(Maybe Int) -- ^ "time" - Time of occurence of event
  , nAWelcomeEventCameraId :: !(Maybe Text) -- ^ "camera_id" - Camera that detected the event
  , nAWelcomeEventPersonId :: !(Maybe Text) -- ^ "person_id" - Id of the person the event is about (if any)
  , nAWelcomeEventSnapshot :: !(Maybe NAWelcomeSnapshot) -- ^ "snapshot"
  , nAWelcomeEventVideoId :: !(Maybe Text) -- ^ "video_id" - Identifier of the video
  , nAWelcomeEventVideoStatus :: !(Maybe Text) -- ^ "video_status" - Status of the video (recording, deleted or available)
  , nAWelcomeEventIsArrival :: !(Maybe Bool) -- ^ "is_arrival" - If person was considered away before being seen during this event
  , nAWelcomeEventMessage :: !(Maybe Text) -- ^ "message" - User facing event description
  , nAWelcomeEventSubType :: !(Maybe Int) -- ^ "sub_type" - Subtypes of SD and Alim events. Go to Welcome page for further details.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeEvent
instance A.FromJSON NAWelcomeEvent where
  parseJSON = A.withObject "NAWelcomeEvent" $ \o ->
    NAWelcomeEvent
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "time")
      <*> (o .:? "camera_id")
      <*> (o .:? "person_id")
      <*> (o .:? "snapshot")
      <*> (o .:? "video_id")
      <*> (o .:? "video_status")
      <*> (o .:? "is_arrival")
      <*> (o .:? "message")
      <*> (o .:? "sub_type")

-- | ToJSON NAWelcomeEvent
instance A.ToJSON NAWelcomeEvent where
  toJSON NAWelcomeEvent {..} =
   _omitNulls
      [ "id" .= nAWelcomeEventId
      , "type" .= nAWelcomeEventType
      , "time" .= nAWelcomeEventTime
      , "camera_id" .= nAWelcomeEventCameraId
      , "person_id" .= nAWelcomeEventPersonId
      , "snapshot" .= nAWelcomeEventSnapshot
      , "video_id" .= nAWelcomeEventVideoId
      , "video_status" .= nAWelcomeEventVideoStatus
      , "is_arrival" .= nAWelcomeEventIsArrival
      , "message" .= nAWelcomeEventMessage
      , "sub_type" .= nAWelcomeEventSubType
      ]


-- | Construct a value of type 'NAWelcomeEvent' (by applying it's required fields, if any)
mkNAWelcomeEvent
  :: NAWelcomeEvent
mkNAWelcomeEvent =
  NAWelcomeEvent
  { nAWelcomeEventId = Nothing
  , nAWelcomeEventType = Nothing
  , nAWelcomeEventTime = Nothing
  , nAWelcomeEventCameraId = Nothing
  , nAWelcomeEventPersonId = Nothing
  , nAWelcomeEventSnapshot = Nothing
  , nAWelcomeEventVideoId = Nothing
  , nAWelcomeEventVideoStatus = Nothing
  , nAWelcomeEventIsArrival = Nothing
  , nAWelcomeEventMessage = Nothing
  , nAWelcomeEventSubType = Nothing
  }

-- ** NAWelcomeEventData
-- | NAWelcomeEventData
data NAWelcomeEventData = NAWelcomeEventData
  { nAWelcomeEventDataEventsList :: !(Maybe [NAWelcomeEvent]) -- ^ "events_list"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeEventData
instance A.FromJSON NAWelcomeEventData where
  parseJSON = A.withObject "NAWelcomeEventData" $ \o ->
    NAWelcomeEventData
      <$> (o .:? "events_list")

-- | ToJSON NAWelcomeEventData
instance A.ToJSON NAWelcomeEventData where
  toJSON NAWelcomeEventData {..} =
   _omitNulls
      [ "events_list" .= nAWelcomeEventDataEventsList
      ]


-- | Construct a value of type 'NAWelcomeEventData' (by applying it's required fields, if any)
mkNAWelcomeEventData
  :: NAWelcomeEventData
mkNAWelcomeEventData =
  NAWelcomeEventData
  { nAWelcomeEventDataEventsList = Nothing
  }

-- ** NAWelcomeEventResponse
-- | NAWelcomeEventResponse
data NAWelcomeEventResponse = NAWelcomeEventResponse
  { nAWelcomeEventResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAWelcomeEventResponseBody :: !(Maybe NAWelcomeEventData) -- ^ "body"
  , nAWelcomeEventResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAWelcomeEventResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeEventResponse
instance A.FromJSON NAWelcomeEventResponse where
  parseJSON = A.withObject "NAWelcomeEventResponse" $ \o ->
    NAWelcomeEventResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAWelcomeEventResponse
instance A.ToJSON NAWelcomeEventResponse where
  toJSON NAWelcomeEventResponse {..} =
   _omitNulls
      [ "status" .= nAWelcomeEventResponseStatus
      , "body" .= nAWelcomeEventResponseBody
      , "time_exec" .= nAWelcomeEventResponseTimeExec
      , "time_server" .= nAWelcomeEventResponseTimeServer
      ]


-- | Construct a value of type 'NAWelcomeEventResponse' (by applying it's required fields, if any)
mkNAWelcomeEventResponse
  :: NAWelcomeEventResponse
mkNAWelcomeEventResponse =
  NAWelcomeEventResponse
  { nAWelcomeEventResponseStatus = Nothing
  , nAWelcomeEventResponseBody = Nothing
  , nAWelcomeEventResponseTimeExec = Nothing
  , nAWelcomeEventResponseTimeServer = Nothing
  }

-- ** NAWelcomeFace
-- | NAWelcomeFace
data NAWelcomeFace = NAWelcomeFace
  { nAWelcomeFaceId :: !(Maybe Text) -- ^ "id" - Id of the face.
  , nAWelcomeFaceVersion :: !(Maybe Int) -- ^ "version" - Version of the face if user changed their photo.
  , nAWelcomeFaceKey :: !(Maybe Text) -- ^ "key" - Key for this face to use in getcamerapicture.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeFace
instance A.FromJSON NAWelcomeFace where
  parseJSON = A.withObject "NAWelcomeFace" $ \o ->
    NAWelcomeFace
      <$> (o .:? "id")
      <*> (o .:? "version")
      <*> (o .:? "key")

-- | ToJSON NAWelcomeFace
instance A.ToJSON NAWelcomeFace where
  toJSON NAWelcomeFace {..} =
   _omitNulls
      [ "id" .= nAWelcomeFaceId
      , "version" .= nAWelcomeFaceVersion
      , "key" .= nAWelcomeFaceKey
      ]


-- | Construct a value of type 'NAWelcomeFace' (by applying it's required fields, if any)
mkNAWelcomeFace
  :: NAWelcomeFace
mkNAWelcomeFace =
  NAWelcomeFace
  { nAWelcomeFaceId = Nothing
  , nAWelcomeFaceVersion = Nothing
  , nAWelcomeFaceKey = Nothing
  }

-- ** NAWelcomeGlobalInfo
-- | NAWelcomeGlobalInfo
data NAWelcomeGlobalInfo = NAWelcomeGlobalInfo
  { nAWelcomeGlobalInfoShowTags :: !(Maybe Bool) -- ^ "show_tags" - show tags
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeGlobalInfo
instance A.FromJSON NAWelcomeGlobalInfo where
  parseJSON = A.withObject "NAWelcomeGlobalInfo" $ \o ->
    NAWelcomeGlobalInfo
      <$> (o .:? "show_tags")

-- | ToJSON NAWelcomeGlobalInfo
instance A.ToJSON NAWelcomeGlobalInfo where
  toJSON NAWelcomeGlobalInfo {..} =
   _omitNulls
      [ "show_tags" .= nAWelcomeGlobalInfoShowTags
      ]


-- | Construct a value of type 'NAWelcomeGlobalInfo' (by applying it's required fields, if any)
mkNAWelcomeGlobalInfo
  :: NAWelcomeGlobalInfo
mkNAWelcomeGlobalInfo =
  NAWelcomeGlobalInfo
  { nAWelcomeGlobalInfoShowTags = Nothing
  }

-- ** NAWelcomeHome
-- | NAWelcomeHome
data NAWelcomeHome = NAWelcomeHome
  { nAWelcomeHomeId :: !(Maybe Text) -- ^ "id" - Id of the home.
  , nAWelcomeHomeName :: !(Maybe Text) -- ^ "name" - Name of the home
  , nAWelcomeHomePersons :: !(Maybe [NAWelcomePerson]) -- ^ "persons"
  , nAWelcomeHomePlace :: !(Maybe NAWelcomePlace) -- ^ "place"
  , nAWelcomeHomeCameras :: !(Maybe [NAWelcomeCamera]) -- ^ "cameras"
  , nAWelcomeHomeEvents :: !(Maybe [NAWelcomeEvent]) -- ^ "events"
  , nAWelcomeHomeModules :: !(Maybe [NAWelcomeModule]) -- ^ "modules"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeHome
instance A.FromJSON NAWelcomeHome where
  parseJSON = A.withObject "NAWelcomeHome" $ \o ->
    NAWelcomeHome
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "persons")
      <*> (o .:? "place")
      <*> (o .:? "cameras")
      <*> (o .:? "events")
      <*> (o .:? "modules")

-- | ToJSON NAWelcomeHome
instance A.ToJSON NAWelcomeHome where
  toJSON NAWelcomeHome {..} =
   _omitNulls
      [ "id" .= nAWelcomeHomeId
      , "name" .= nAWelcomeHomeName
      , "persons" .= nAWelcomeHomePersons
      , "place" .= nAWelcomeHomePlace
      , "cameras" .= nAWelcomeHomeCameras
      , "events" .= nAWelcomeHomeEvents
      , "modules" .= nAWelcomeHomeModules
      ]


-- | Construct a value of type 'NAWelcomeHome' (by applying it's required fields, if any)
mkNAWelcomeHome
  :: NAWelcomeHome
mkNAWelcomeHome =
  NAWelcomeHome
  { nAWelcomeHomeId = Nothing
  , nAWelcomeHomeName = Nothing
  , nAWelcomeHomePersons = Nothing
  , nAWelcomeHomePlace = Nothing
  , nAWelcomeHomeCameras = Nothing
  , nAWelcomeHomeEvents = Nothing
  , nAWelcomeHomeModules = Nothing
  }

-- ** NAWelcomeHomeData
-- | NAWelcomeHomeData
data NAWelcomeHomeData = NAWelcomeHomeData
  { nAWelcomeHomeDataHomes :: !(Maybe [NAWelcomeHome]) -- ^ "homes"
  , nAWelcomeHomeDataUser :: !(Maybe NAWelcomeUser) -- ^ "user"
  , nAWelcomeHomeDataGlobalInfo :: !(Maybe NAWelcomeGlobalInfo) -- ^ "global_info"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeHomeData
instance A.FromJSON NAWelcomeHomeData where
  parseJSON = A.withObject "NAWelcomeHomeData" $ \o ->
    NAWelcomeHomeData
      <$> (o .:? "homes")
      <*> (o .:? "user")
      <*> (o .:? "global_info")

-- | ToJSON NAWelcomeHomeData
instance A.ToJSON NAWelcomeHomeData where
  toJSON NAWelcomeHomeData {..} =
   _omitNulls
      [ "homes" .= nAWelcomeHomeDataHomes
      , "user" .= nAWelcomeHomeDataUser
      , "global_info" .= nAWelcomeHomeDataGlobalInfo
      ]


-- | Construct a value of type 'NAWelcomeHomeData' (by applying it's required fields, if any)
mkNAWelcomeHomeData
  :: NAWelcomeHomeData
mkNAWelcomeHomeData =
  NAWelcomeHomeData
  { nAWelcomeHomeDataHomes = Nothing
  , nAWelcomeHomeDataUser = Nothing
  , nAWelcomeHomeDataGlobalInfo = Nothing
  }

-- ** NAWelcomeHomeDataResponse
-- | NAWelcomeHomeDataResponse
data NAWelcomeHomeDataResponse = NAWelcomeHomeDataResponse
  { nAWelcomeHomeDataResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAWelcomeHomeDataResponseBody :: !(Maybe NAWelcomeHomeData) -- ^ "body"
  , nAWelcomeHomeDataResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAWelcomeHomeDataResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeHomeDataResponse
instance A.FromJSON NAWelcomeHomeDataResponse where
  parseJSON = A.withObject "NAWelcomeHomeDataResponse" $ \o ->
    NAWelcomeHomeDataResponse
      <$> (o .:? "status")
      <*> (o .:? "body")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAWelcomeHomeDataResponse
instance A.ToJSON NAWelcomeHomeDataResponse where
  toJSON NAWelcomeHomeDataResponse {..} =
   _omitNulls
      [ "status" .= nAWelcomeHomeDataResponseStatus
      , "body" .= nAWelcomeHomeDataResponseBody
      , "time_exec" .= nAWelcomeHomeDataResponseTimeExec
      , "time_server" .= nAWelcomeHomeDataResponseTimeServer
      ]


-- | Construct a value of type 'NAWelcomeHomeDataResponse' (by applying it's required fields, if any)
mkNAWelcomeHomeDataResponse
  :: NAWelcomeHomeDataResponse
mkNAWelcomeHomeDataResponse =
  NAWelcomeHomeDataResponse
  { nAWelcomeHomeDataResponseStatus = Nothing
  , nAWelcomeHomeDataResponseBody = Nothing
  , nAWelcomeHomeDataResponseTimeExec = Nothing
  , nAWelcomeHomeDataResponseTimeServer = Nothing
  }

-- ** NAWelcomeModule
-- | NAWelcomeModule
data NAWelcomeModule = NAWelcomeModule
  { nAWelcomeModuleId :: !(Maybe Text) -- ^ "id" - mac address of the module
  , nAWelcomeModuleType :: !(Maybe Text) -- ^ "type" - NACamDoorTag for tags
  , nAWelcomeModuleName :: !(Maybe Text) -- ^ "name" - name of the module (given by the user)
  , nAWelcomeModuleBatteryPercent :: !(Maybe Int) -- ^ "battery_percent" - remaining battery percentage
  , nAWelcomeModuleStatus :: !(Maybe Text) -- ^ "status" - status of the module
  , nAWelcomeModuleRf :: !(Maybe Text) -- ^ "rf" - Radio status
  , nAWelcomeModuleLastActivity :: !(Maybe Int) -- ^ "last_activity" - Timestamp of last move detected by the module
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeModule
instance A.FromJSON NAWelcomeModule where
  parseJSON = A.withObject "NAWelcomeModule" $ \o ->
    NAWelcomeModule
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "name")
      <*> (o .:? "battery_percent")
      <*> (o .:? "status")
      <*> (o .:? "rf")
      <*> (o .:? "last_activity")

-- | ToJSON NAWelcomeModule
instance A.ToJSON NAWelcomeModule where
  toJSON NAWelcomeModule {..} =
   _omitNulls
      [ "id" .= nAWelcomeModuleId
      , "type" .= nAWelcomeModuleType
      , "name" .= nAWelcomeModuleName
      , "battery_percent" .= nAWelcomeModuleBatteryPercent
      , "status" .= nAWelcomeModuleStatus
      , "rf" .= nAWelcomeModuleRf
      , "last_activity" .= nAWelcomeModuleLastActivity
      ]


-- | Construct a value of type 'NAWelcomeModule' (by applying it's required fields, if any)
mkNAWelcomeModule
  :: NAWelcomeModule
mkNAWelcomeModule =
  NAWelcomeModule
  { nAWelcomeModuleId = Nothing
  , nAWelcomeModuleType = Nothing
  , nAWelcomeModuleName = Nothing
  , nAWelcomeModuleBatteryPercent = Nothing
  , nAWelcomeModuleStatus = Nothing
  , nAWelcomeModuleRf = Nothing
  , nAWelcomeModuleLastActivity = Nothing
  }

-- ** NAWelcomePerson
-- | NAWelcomePerson
data NAWelcomePerson = NAWelcomePerson
  { nAWelcomePersonId :: !(Maybe Text) -- ^ "id" - Id of the person.
  , nAWelcomePersonLastSeen :: !(Maybe Int) -- ^ "last_seen" - Time at which the person was last seen.
  , nAWelcomePersonOutOfSight :: !(Maybe Bool) -- ^ "out_of_sight" - True if the Person is out of sight.
  , nAWelcomePersonFace :: !(Maybe NAWelcomeFace) -- ^ "face"
  , nAWelcomePersonPseudo :: !(Maybe Text) -- ^ "pseudo" - Name of the person, if pseudo is missing, person is unknown.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomePerson
instance A.FromJSON NAWelcomePerson where
  parseJSON = A.withObject "NAWelcomePerson" $ \o ->
    NAWelcomePerson
      <$> (o .:? "id")
      <*> (o .:? "last_seen")
      <*> (o .:? "out_of_sight")
      <*> (o .:? "face")
      <*> (o .:? "pseudo")

-- | ToJSON NAWelcomePerson
instance A.ToJSON NAWelcomePerson where
  toJSON NAWelcomePerson {..} =
   _omitNulls
      [ "id" .= nAWelcomePersonId
      , "last_seen" .= nAWelcomePersonLastSeen
      , "out_of_sight" .= nAWelcomePersonOutOfSight
      , "face" .= nAWelcomePersonFace
      , "pseudo" .= nAWelcomePersonPseudo
      ]


-- | Construct a value of type 'NAWelcomePerson' (by applying it's required fields, if any)
mkNAWelcomePerson
  :: NAWelcomePerson
mkNAWelcomePerson =
  NAWelcomePerson
  { nAWelcomePersonId = Nothing
  , nAWelcomePersonLastSeen = Nothing
  , nAWelcomePersonOutOfSight = Nothing
  , nAWelcomePersonFace = Nothing
  , nAWelcomePersonPseudo = Nothing
  }

-- ** NAWelcomePersonsAwayResponse
-- | NAWelcomePersonsAwayResponse
data NAWelcomePersonsAwayResponse = NAWelcomePersonsAwayResponse
  { nAWelcomePersonsAwayResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAWelcomePersonsAwayResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAWelcomePersonsAwayResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomePersonsAwayResponse
instance A.FromJSON NAWelcomePersonsAwayResponse where
  parseJSON = A.withObject "NAWelcomePersonsAwayResponse" $ \o ->
    NAWelcomePersonsAwayResponse
      <$> (o .:? "status")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAWelcomePersonsAwayResponse
instance A.ToJSON NAWelcomePersonsAwayResponse where
  toJSON NAWelcomePersonsAwayResponse {..} =
   _omitNulls
      [ "status" .= nAWelcomePersonsAwayResponseStatus
      , "time_exec" .= nAWelcomePersonsAwayResponseTimeExec
      , "time_server" .= nAWelcomePersonsAwayResponseTimeServer
      ]


-- | Construct a value of type 'NAWelcomePersonsAwayResponse' (by applying it's required fields, if any)
mkNAWelcomePersonsAwayResponse
  :: NAWelcomePersonsAwayResponse
mkNAWelcomePersonsAwayResponse =
  NAWelcomePersonsAwayResponse
  { nAWelcomePersonsAwayResponseStatus = Nothing
  , nAWelcomePersonsAwayResponseTimeExec = Nothing
  , nAWelcomePersonsAwayResponseTimeServer = Nothing
  }

-- ** NAWelcomePersonsHomeResponse
-- | NAWelcomePersonsHomeResponse
data NAWelcomePersonsHomeResponse = NAWelcomePersonsHomeResponse
  { nAWelcomePersonsHomeResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAWelcomePersonsHomeResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  , nAWelcomePersonsHomeResponseTimeServer :: !(Maybe Int) -- ^ "time_server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomePersonsHomeResponse
instance A.FromJSON NAWelcomePersonsHomeResponse where
  parseJSON = A.withObject "NAWelcomePersonsHomeResponse" $ \o ->
    NAWelcomePersonsHomeResponse
      <$> (o .:? "status")
      <*> (o .:? "time_exec")
      <*> (o .:? "time_server")

-- | ToJSON NAWelcomePersonsHomeResponse
instance A.ToJSON NAWelcomePersonsHomeResponse where
  toJSON NAWelcomePersonsHomeResponse {..} =
   _omitNulls
      [ "status" .= nAWelcomePersonsHomeResponseStatus
      , "time_exec" .= nAWelcomePersonsHomeResponseTimeExec
      , "time_server" .= nAWelcomePersonsHomeResponseTimeServer
      ]


-- | Construct a value of type 'NAWelcomePersonsHomeResponse' (by applying it's required fields, if any)
mkNAWelcomePersonsHomeResponse
  :: NAWelcomePersonsHomeResponse
mkNAWelcomePersonsHomeResponse =
  NAWelcomePersonsHomeResponse
  { nAWelcomePersonsHomeResponseStatus = Nothing
  , nAWelcomePersonsHomeResponseTimeExec = Nothing
  , nAWelcomePersonsHomeResponseTimeServer = Nothing
  }

-- ** NAWelcomePlace
-- | NAWelcomePlace
data NAWelcomePlace = NAWelcomePlace
  { nAWelcomePlaceCity :: !(Maybe Text) -- ^ "city" - City of the home.
  , nAWelcomePlaceCountry :: !(Maybe Text) -- ^ "country" - Country of the home.
  , nAWelcomePlaceTimezone :: !(Maybe Text) -- ^ "timezone" - Timezone of the home.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomePlace
instance A.FromJSON NAWelcomePlace where
  parseJSON = A.withObject "NAWelcomePlace" $ \o ->
    NAWelcomePlace
      <$> (o .:? "city")
      <*> (o .:? "country")
      <*> (o .:? "timezone")

-- | ToJSON NAWelcomePlace
instance A.ToJSON NAWelcomePlace where
  toJSON NAWelcomePlace {..} =
   _omitNulls
      [ "city" .= nAWelcomePlaceCity
      , "country" .= nAWelcomePlaceCountry
      , "timezone" .= nAWelcomePlaceTimezone
      ]


-- | Construct a value of type 'NAWelcomePlace' (by applying it's required fields, if any)
mkNAWelcomePlace
  :: NAWelcomePlace
mkNAWelcomePlace =
  NAWelcomePlace
  { nAWelcomePlaceCity = Nothing
  , nAWelcomePlaceCountry = Nothing
  , nAWelcomePlaceTimezone = Nothing
  }

-- ** NAWelcomeSnapshot
-- | NAWelcomeSnapshot
data NAWelcomeSnapshot = NAWelcomeSnapshot
  { nAWelcomeSnapshotId :: !(Maybe Text) -- ^ "id" - Id of the snapshot.
  , nAWelcomeSnapshotVersion :: !(Maybe Int) -- ^ "version" - Version of the snapshot.
  , nAWelcomeSnapshotKey :: !(Maybe Text) -- ^ "key" - Key for this snapshot.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeSnapshot
instance A.FromJSON NAWelcomeSnapshot where
  parseJSON = A.withObject "NAWelcomeSnapshot" $ \o ->
    NAWelcomeSnapshot
      <$> (o .:? "id")
      <*> (o .:? "version")
      <*> (o .:? "key")

-- | ToJSON NAWelcomeSnapshot
instance A.ToJSON NAWelcomeSnapshot where
  toJSON NAWelcomeSnapshot {..} =
   _omitNulls
      [ "id" .= nAWelcomeSnapshotId
      , "version" .= nAWelcomeSnapshotVersion
      , "key" .= nAWelcomeSnapshotKey
      ]


-- | Construct a value of type 'NAWelcomeSnapshot' (by applying it's required fields, if any)
mkNAWelcomeSnapshot
  :: NAWelcomeSnapshot
mkNAWelcomeSnapshot =
  NAWelcomeSnapshot
  { nAWelcomeSnapshotId = Nothing
  , nAWelcomeSnapshotVersion = Nothing
  , nAWelcomeSnapshotKey = Nothing
  }

-- ** NAWelcomeUser
-- | NAWelcomeUser
data NAWelcomeUser = NAWelcomeUser
  { nAWelcomeUserLang :: !(Maybe Text) -- ^ "lang" - user locale
  , nAWelcomeUserRegLocale :: !(Maybe Text) -- ^ "reg_locale" - user regional preferences (used for displaying date)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeUser
instance A.FromJSON NAWelcomeUser where
  parseJSON = A.withObject "NAWelcomeUser" $ \o ->
    NAWelcomeUser
      <$> (o .:? "lang")
      <*> (o .:? "reg_locale")

-- | ToJSON NAWelcomeUser
instance A.ToJSON NAWelcomeUser where
  toJSON NAWelcomeUser {..} =
   _omitNulls
      [ "lang" .= nAWelcomeUserLang
      , "reg_locale" .= nAWelcomeUserRegLocale
      ]


-- | Construct a value of type 'NAWelcomeUser' (by applying it's required fields, if any)
mkNAWelcomeUser
  :: NAWelcomeUser
mkNAWelcomeUser =
  NAWelcomeUser
  { nAWelcomeUserLang = Nothing
  , nAWelcomeUserRegLocale = Nothing
  }

-- ** NAWelcomeWebhookResponse
-- | NAWelcomeWebhookResponse
data NAWelcomeWebhookResponse = NAWelcomeWebhookResponse
  { nAWelcomeWebhookResponseStatus :: !(Maybe Text) -- ^ "status"
  , nAWelcomeWebhookResponseTimeExec :: !(Maybe Double) -- ^ "time_exec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAWelcomeWebhookResponse
instance A.FromJSON NAWelcomeWebhookResponse where
  parseJSON = A.withObject "NAWelcomeWebhookResponse" $ \o ->
    NAWelcomeWebhookResponse
      <$> (o .:? "status")
      <*> (o .:? "time_exec")

-- | ToJSON NAWelcomeWebhookResponse
instance A.ToJSON NAWelcomeWebhookResponse where
  toJSON NAWelcomeWebhookResponse {..} =
   _omitNulls
      [ "status" .= nAWelcomeWebhookResponseStatus
      , "time_exec" .= nAWelcomeWebhookResponseTimeExec
      ]


-- | Construct a value of type 'NAWelcomeWebhookResponse' (by applying it's required fields, if any)
mkNAWelcomeWebhookResponse
  :: NAWelcomeWebhookResponse
mkNAWelcomeWebhookResponse =
  NAWelcomeWebhookResponse
  { nAWelcomeWebhookResponseStatus = Nothing
  , nAWelcomeWebhookResponseTimeExec = Nothing
  }

-- ** NAYearMonth
-- | NAYearMonth
data NAYearMonth = NAYearMonth
  { nAYearMonthY :: !(Maybe Int) -- ^ "y"
  , nAYearMonthM :: !(Maybe Int) -- ^ "m"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAYearMonth
instance A.FromJSON NAYearMonth where
  parseJSON = A.withObject "NAYearMonth" $ \o ->
    NAYearMonth
      <$> (o .:? "y")
      <*> (o .:? "m")

-- | ToJSON NAYearMonth
instance A.ToJSON NAYearMonth where
  toJSON NAYearMonth {..} =
   _omitNulls
      [ "y" .= nAYearMonthY
      , "m" .= nAYearMonthM
      ]


-- | Construct a value of type 'NAYearMonth' (by applying it's required fields, if any)
mkNAYearMonth
  :: NAYearMonth
mkNAYearMonth =
  NAYearMonth
  { nAYearMonthY = Nothing
  , nAYearMonthM = Nothing
  }

-- ** NAZone
-- | NAZone
data NAZone = NAZone
  { nAZoneId :: !(Maybe Int) -- ^ "id"
  , nAZoneType :: !(Maybe Int) -- ^ "type"
  , nAZoneName :: !(Maybe Text) -- ^ "name"
  , nAZoneTemp :: !(Maybe Float) -- ^ "temp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NAZone
instance A.FromJSON NAZone where
  parseJSON = A.withObject "NAZone" $ \o ->
    NAZone
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "name")
      <*> (o .:? "temp")

-- | ToJSON NAZone
instance A.ToJSON NAZone where
  toJSON NAZone {..} =
   _omitNulls
      [ "id" .= nAZoneId
      , "type" .= nAZoneType
      , "name" .= nAZoneName
      , "temp" .= nAZoneTemp
      ]


-- | Construct a value of type 'NAZone' (by applying it's required fields, if any)
mkNAZone
  :: NAZone
mkNAZone =
  NAZone
  { nAZoneId = Nothing
  , nAZoneType = Nothing
  , nAZoneName = Nothing
  , nAZoneTemp = Nothing
  }


-- * Enums


-- ** E'AppType

-- | Enum of 'Text'
data E'AppType
  = E'AppType'Thermostat -- ^ @"app_thermostat"@
  | E'AppType'Station -- ^ @"app_station"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AppType where toJSON = A.toJSON . fromE'AppType
instance A.FromJSON E'AppType where parseJSON o = P.either P.fail (pure . P.id) . toE'AppType =<< A.parseJSON o
instance WH.ToHttpApiData E'AppType where toQueryParam = WH.toQueryParam . fromE'AppType
instance WH.FromHttpApiData E'AppType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AppType
instance MimeRender MimeMultipartFormData E'AppType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AppType' enum
fromE'AppType :: E'AppType -> Text
fromE'AppType = \case
  E'AppType'Thermostat -> "app_thermostat"
  E'AppType'Station -> "app_station"

-- | parse 'E'AppType' enum
toE'AppType :: Text -> P.Either String E'AppType
toE'AppType = \case
  "app_thermostat" -> P.Right E'AppType'Thermostat
  "app_station" -> P.Right E'AppType'Station
  s -> P.Left $ "toE'AppType: enum parse failure: " P.++ P.show s


-- ** E'RequiredData

-- | Enum of 'Text'
data E'RequiredData
  = E'RequiredData'Temperature -- ^ @"temperature"@
  | E'RequiredData'Humidity -- ^ @"humidity"@
  | E'RequiredData'Pressure -- ^ @"pressure"@
  | E'RequiredData'Wind -- ^ @"wind"@
  | E'RequiredData'Rain -- ^ @"rain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RequiredData where toJSON = A.toJSON . fromE'RequiredData
instance A.FromJSON E'RequiredData where parseJSON o = P.either P.fail (pure . P.id) . toE'RequiredData =<< A.parseJSON o
instance WH.ToHttpApiData E'RequiredData where toQueryParam = WH.toQueryParam . fromE'RequiredData
instance WH.FromHttpApiData E'RequiredData where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RequiredData
instance MimeRender MimeMultipartFormData E'RequiredData where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RequiredData' enum
fromE'RequiredData :: E'RequiredData -> Text
fromE'RequiredData = \case
  E'RequiredData'Temperature -> "temperature"
  E'RequiredData'Humidity -> "humidity"
  E'RequiredData'Pressure -> "pressure"
  E'RequiredData'Wind -> "wind"
  E'RequiredData'Rain -> "rain"

-- | parse 'E'RequiredData' enum
toE'RequiredData :: Text -> P.Either String E'RequiredData
toE'RequiredData = \case
  "temperature" -> P.Right E'RequiredData'Temperature
  "humidity" -> P.Right E'RequiredData'Humidity
  "pressure" -> P.Right E'RequiredData'Pressure
  "wind" -> P.Right E'RequiredData'Wind
  "rain" -> P.Right E'RequiredData'Rain
  s -> P.Left $ "toE'RequiredData: enum parse failure: " P.++ P.show s


-- ** E'Scale

-- | Enum of 'Text'
data E'Scale
  = E'Scale'Max -- ^ @"max"@
  | E'Scale'30min -- ^ @"30min"@
  | E'Scale'1hour -- ^ @"1hour"@
  | E'Scale'3hours -- ^ @"3hours"@
  | E'Scale'1day -- ^ @"1day"@
  | E'Scale'1week -- ^ @"1week"@
  | E'Scale'1month -- ^ @"1month"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scale where toJSON = A.toJSON . fromE'Scale
instance A.FromJSON E'Scale where parseJSON o = P.either P.fail (pure . P.id) . toE'Scale =<< A.parseJSON o
instance WH.ToHttpApiData E'Scale where toQueryParam = WH.toQueryParam . fromE'Scale
instance WH.FromHttpApiData E'Scale where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scale
instance MimeRender MimeMultipartFormData E'Scale where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scale' enum
fromE'Scale :: E'Scale -> Text
fromE'Scale = \case
  E'Scale'Max -> "max"
  E'Scale'30min -> "30min"
  E'Scale'1hour -> "1hour"
  E'Scale'3hours -> "3hours"
  E'Scale'1day -> "1day"
  E'Scale'1week -> "1week"
  E'Scale'1month -> "1month"

-- | parse 'E'Scale' enum
toE'Scale :: Text -> P.Either String E'Scale
toE'Scale = \case
  "max" -> P.Right E'Scale'Max
  "30min" -> P.Right E'Scale'30min
  "1hour" -> P.Right E'Scale'1hour
  "3hours" -> P.Right E'Scale'3hours
  "1day" -> P.Right E'Scale'1day
  "1week" -> P.Right E'Scale'1week
  "1month" -> P.Right E'Scale'1month
  s -> P.Left $ "toE'Scale: enum parse failure: " P.++ P.show s


-- ** E'SetpointMode

-- | Enum of 'Text'
data E'SetpointMode
  = E'SetpointMode'Program -- ^ @"program"@
  | E'SetpointMode'Away -- ^ @"away"@
  | E'SetpointMode'Hg -- ^ @"hg"@
  | E'SetpointMode'Manual -- ^ @"manual"@
  | E'SetpointMode'Off -- ^ @"off"@
  | E'SetpointMode'Max -- ^ @"max"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SetpointMode where toJSON = A.toJSON . fromE'SetpointMode
instance A.FromJSON E'SetpointMode where parseJSON o = P.either P.fail (pure . P.id) . toE'SetpointMode =<< A.parseJSON o
instance WH.ToHttpApiData E'SetpointMode where toQueryParam = WH.toQueryParam . fromE'SetpointMode
instance WH.FromHttpApiData E'SetpointMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SetpointMode
instance MimeRender MimeMultipartFormData E'SetpointMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SetpointMode' enum
fromE'SetpointMode :: E'SetpointMode -> Text
fromE'SetpointMode = \case
  E'SetpointMode'Program -> "program"
  E'SetpointMode'Away -> "away"
  E'SetpointMode'Hg -> "hg"
  E'SetpointMode'Manual -> "manual"
  E'SetpointMode'Off -> "off"
  E'SetpointMode'Max -> "max"

-- | parse 'E'SetpointMode' enum
toE'SetpointMode :: Text -> P.Either String E'SetpointMode
toE'SetpointMode = \case
  "program" -> P.Right E'SetpointMode'Program
  "away" -> P.Right E'SetpointMode'Away
  "hg" -> P.Right E'SetpointMode'Hg
  "manual" -> P.Right E'SetpointMode'Manual
  "off" -> P.Right E'SetpointMode'Off
  "max" -> P.Right E'SetpointMode'Max
  s -> P.Left $ "toE'SetpointMode: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Temperature -- ^ @"Temperature"@
  | E'Type'CO2 -- ^ @"CO2"@
  | E'Type'Humidity -- ^ @"Humidity"@
  | E'Type'Pressure -- ^ @"Pressure"@
  | E'Type'Noise -- ^ @"Noise"@
  | E'Type'Rain -- ^ @"Rain"@
  | E'Type'WindStrength -- ^ @"WindStrength"@
  | E'Type'WindAngle -- ^ @"WindAngle"@
  | E'Type'Guststrength -- ^ @"Guststrength"@
  | E'Type'GustAngle -- ^ @"GustAngle"@
  | E'Type'Sp_Temperature -- ^ @"Sp_Temperature"@
  | E'Type'BoilerOn -- ^ @"BoilerOn"@
  | E'Type'BoilerOff -- ^ @"BoilerOff"@
  | E'Type'Min_temp -- ^ @"min_temp"@
  | E'Type'Date_min_temp -- ^ @"date_min_temp"@
  | E'Type'Max_temp -- ^ @"max_temp"@
  | E'Type'Date_max_temp -- ^ @"date_max_temp"@
  | E'Type'Min_hum -- ^ @"min_hum"@
  | E'Type'Date_min_hum -- ^ @"date_min_hum"@
  | E'Type'Max_hum -- ^ @"max_hum"@
  | E'Type'Date_max_hum -- ^ @"date_max_hum"@
  | E'Type'Min_pressure -- ^ @"min_pressure"@
  | E'Type'Date_min_pressure -- ^ @"date_min_pressure"@
  | E'Type'Max_pressure -- ^ @"max_pressure"@
  | E'Type'Date_max_pressure -- ^ @"date_max_pressure"@
  | E'Type'Min_noise -- ^ @"min_noise"@
  | E'Type'Date_min_noise -- ^ @"date_min_noise"@
  | E'Type'Max_noise -- ^ @"max_noise"@
  | E'Type'Date_max_noise -- ^ @"date_max_noise"@
  | E'Type'Date_min_co2 -- ^ @"date_min_co2"@
  | E'Type'Date_max_co2 -- ^ @"date_max_co2"@
  | E'Type'Date_max_gust -- ^ @"date_max_gust"@
  | E'Type'Sum_rain -- ^ @"sum_rain"@
  | E'Type'Sum_boiler_on -- ^ @"sum_boiler_on"@
  | E'Type'Sum_boiler_off -- ^ @"sum_boiler_off"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Temperature -> "Temperature"
  E'Type'CO2 -> "CO2"
  E'Type'Humidity -> "Humidity"
  E'Type'Pressure -> "Pressure"
  E'Type'Noise -> "Noise"
  E'Type'Rain -> "Rain"
  E'Type'WindStrength -> "WindStrength"
  E'Type'WindAngle -> "WindAngle"
  E'Type'Guststrength -> "Guststrength"
  E'Type'GustAngle -> "GustAngle"
  E'Type'Sp_Temperature -> "Sp_Temperature"
  E'Type'BoilerOn -> "BoilerOn"
  E'Type'BoilerOff -> "BoilerOff"
  E'Type'Min_temp -> "min_temp"
  E'Type'Date_min_temp -> "date_min_temp"
  E'Type'Max_temp -> "max_temp"
  E'Type'Date_max_temp -> "date_max_temp"
  E'Type'Min_hum -> "min_hum"
  E'Type'Date_min_hum -> "date_min_hum"
  E'Type'Max_hum -> "max_hum"
  E'Type'Date_max_hum -> "date_max_hum"
  E'Type'Min_pressure -> "min_pressure"
  E'Type'Date_min_pressure -> "date_min_pressure"
  E'Type'Max_pressure -> "max_pressure"
  E'Type'Date_max_pressure -> "date_max_pressure"
  E'Type'Min_noise -> "min_noise"
  E'Type'Date_min_noise -> "date_min_noise"
  E'Type'Max_noise -> "max_noise"
  E'Type'Date_max_noise -> "date_max_noise"
  E'Type'Date_min_co2 -> "date_min_co2"
  E'Type'Date_max_co2 -> "date_max_co2"
  E'Type'Date_max_gust -> "date_max_gust"
  E'Type'Sum_rain -> "sum_rain"
  E'Type'Sum_boiler_on -> "sum_boiler_on"
  E'Type'Sum_boiler_off -> "sum_boiler_off"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "Temperature" -> P.Right E'Type'Temperature
  "CO2" -> P.Right E'Type'CO2
  "Humidity" -> P.Right E'Type'Humidity
  "Pressure" -> P.Right E'Type'Pressure
  "Noise" -> P.Right E'Type'Noise
  "Rain" -> P.Right E'Type'Rain
  "WindStrength" -> P.Right E'Type'WindStrength
  "WindAngle" -> P.Right E'Type'WindAngle
  "Guststrength" -> P.Right E'Type'Guststrength
  "GustAngle" -> P.Right E'Type'GustAngle
  "Sp_Temperature" -> P.Right E'Type'Sp_Temperature
  "BoilerOn" -> P.Right E'Type'BoilerOn
  "BoilerOff" -> P.Right E'Type'BoilerOff
  "min_temp" -> P.Right E'Type'Min_temp
  "date_min_temp" -> P.Right E'Type'Date_min_temp
  "max_temp" -> P.Right E'Type'Max_temp
  "date_max_temp" -> P.Right E'Type'Date_max_temp
  "min_hum" -> P.Right E'Type'Min_hum
  "date_min_hum" -> P.Right E'Type'Date_min_hum
  "max_hum" -> P.Right E'Type'Max_hum
  "date_max_hum" -> P.Right E'Type'Date_max_hum
  "min_pressure" -> P.Right E'Type'Min_pressure
  "date_min_pressure" -> P.Right E'Type'Date_min_pressure
  "max_pressure" -> P.Right E'Type'Max_pressure
  "date_max_pressure" -> P.Right E'Type'Date_max_pressure
  "min_noise" -> P.Right E'Type'Min_noise
  "date_min_noise" -> P.Right E'Type'Date_min_noise
  "max_noise" -> P.Right E'Type'Max_noise
  "date_max_noise" -> P.Right E'Type'Date_max_noise
  "date_min_co2" -> P.Right E'Type'Date_min_co2
  "date_max_co2" -> P.Right E'Type'Date_max_co2
  "date_max_gust" -> P.Right E'Type'Date_max_gust
  "sum_rain" -> P.Right E'Type'Sum_rain
  "sum_boiler_on" -> P.Right E'Type'Sum_boiler_on
  "sum_boiler_off" -> P.Right E'Type'Sum_boiler_off
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthOAuthCodeOauth
data AuthOAuthCodeOauth =
  AuthOAuthCodeOauth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthCodeOauth where
  applyAuthMethod _ a@(AuthOAuthCodeOauth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthOAuthPasswordOauth
data AuthOAuthPasswordOauth =
  AuthOAuthPasswordOauth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthPasswordOauth where
  applyAuthMethod _ a@(AuthOAuthPasswordOauth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


